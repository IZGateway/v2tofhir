<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ParserUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">HL7 Version 2 to FHIR Conversion</a> &gt; <a href="index.source.html" class="el_package">gov.cdc.izgw.v2tofhir.utils</a> &gt; <span class="el_source">ParserUtils.java</span></div><h1>ParserUtils.java</h1><pre class="source lang-java linenums">package gov.cdc.izgw.v2tofhir.utils;
import java.io.IOException;
import java.io.StringReader;
import java.lang.reflect.InvocationTargetException;
import java.util.Arrays;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.regex.Pattern;

import org.apache.commons.lang3.StringUtils;
import org.hl7.fhir.instance.model.api.IBase;
import org.hl7.fhir.instance.model.api.IBaseResource;
import org.hl7.fhir.r4.model.DomainResource;
import org.hl7.fhir.r4.model.HumanName;
import org.hl7.fhir.r4.model.IdType;
import org.hl7.fhir.r4.model.Identifier;
import org.hl7.fhir.r4.model.Property;
import org.hl7.fhir.r4.model.Reference;
import org.hl7.fhir.r4.model.Resource;
import org.hl7.fhir.r4.model.StringType;

import ca.uhn.hl7v2.HL7Exception;
import ca.uhn.hl7v2.model.Composite;
import ca.uhn.hl7v2.model.Group;
import ca.uhn.hl7v2.model.Message;
import ca.uhn.hl7v2.model.Primitive;
import ca.uhn.hl7v2.model.Segment;
import ca.uhn.hl7v2.model.Structure;
import ca.uhn.hl7v2.model.Type;
import ca.uhn.hl7v2.model.Varies;
import gov.cdc.izgw.v2tofhir.converter.DatatypeConverter;
import lombok.extern.slf4j.Slf4j;

/**
 * ParserUtils is a utility class supporting Parsing of V2 messages into FHIR
 * 
 * @author Audacious Inquiry
 *
 */
<span class="fc" id="L40">@Slf4j</span>
public class ParserUtils {
	/** Where the reference is stored in user data */
	private static final String REFERENCE_LINK = &quot;Reference&quot;;
	private static final String UNEXPECTED_HL7_EXCEPTION = &quot;Unexpected HL7Exception: {}&quot;;
	/** Key under which search names are stored for a reference */
	public static final String SEARCH_NAMES = &quot;searchNames&quot;;
	/** Key under which reverse search names are stored for a reference */
	public static final String REVERSE_NAMES = &quot;reverseNames&quot;;
	private ParserUtils() {}
	
	/**
	 * Remove the string at the given position from the array
	 * @param lineParts	The String array
	 * @param position	The position
	 * @return	The new array with the specified string removed
	 */
	public static String[] removeArrayElement(String[] lineParts, int position) {
<span class="pc bpc" id="L58" title="1 of 4 branches missed.">		if (lineParts.length &lt;= 1 &amp;&amp; position &lt; lineParts.length) {</span>
<span class="fc" id="L59">			return new String[0];</span>
		} 
<span class="fc" id="L61">		String[] newArray = new String[lineParts.length - 1];</span>
<span class="pc bpc" id="L62" title="1 of 2 branches missed.">		if (position &lt; lineParts.length) {</span>
<span class="fc" id="L63">			System.arraycopy(lineParts, 0, newArray, 0, position);</span>
		} 
<span class="pc bpc" id="L65" title="1 of 2 branches missed.">		if (lineParts.length &gt; position + 1) {</span>
<span class="nc" id="L66">			System.arraycopy(lineParts, position + 1, newArray, position,</span>
				lineParts.length - position - 1);
		}
<span class="fc" id="L69">		return newArray;</span>
	}
	
	/**
	 * Convert a list of values into a Pattern that matches it (case insensitively)
	 * 
	 * This method is used to create Matchers to match sets of known values (e.g., states, countries,
	 * street name abbreviations, et cetera).
	 * 
	 * @param values	The values to convert
	 * @return	A compiled pattern that matches the specified string
	 */
	public static Pattern toPattern(String... values) {
<span class="fc" id="L82">		StringBuilder b = new StringBuilder();</span>
<span class="fc bfc" id="L83" title="All 2 branches covered.">		for (String value : values) {</span>
<span class="fc" id="L84">			b.append(&quot;^&quot;).append(value).append(&quot;$|&quot;);</span>
		}
<span class="fc" id="L86">		b.setLength(b.length() - 1);</span>
<span class="fc" id="L87">		return Pattern.compile(b.toString(), Pattern.CASE_INSENSITIVE);</span>
	}
	
	/**
     * Convert a HAPI V2 datatype to a String
     * @param type The Type to convert
     * @return The string conversion
     */
    public static String toString(Type type) {
<span class="fc bfc" id="L96" title="All 2 branches covered.">		if (type == null) {</span>
<span class="fc" id="L97">			return null;</span>
		}
<span class="pc bpc" id="L99" title="1 of 2 branches missed.">		while (type != null) {</span>
<span class="fc" id="L100">			type = DatatypeConverter.adjustIfVaries(type);</span>
<span class="fc bfc" id="L101" title="All 2 branches covered.">			if (type instanceof Primitive pt) {</span>
<span class="fc" id="L102">				return pt.getValue();</span>
			}
<span class="pc bpc" id="L104" title="1 of 2 branches missed.">			if (type instanceof Composite comp) {</span>
<span class="fc" id="L105">				return toString(comp, 0);</span>
			} 
<span class="nc bnc" id="L107" title="All 2 branches missed.">			if (type instanceof Varies v) {</span>
<span class="nc" id="L108">				type = v.getData();</span>
			} else {
<span class="nc" id="L110">				return null;</span>
			}
		}
<span class="nc" id="L113">		return null;</span>
	}

    /**
     * Convert a field to a string
     * @param segment	The segment
     * @param fieldNo	The field
     * @return	The field converted to a string
     */
	public static String toString(Segment segment, int fieldNo) {
<span class="fc" id="L123">		return toString(getField(segment, fieldNo));</span>
	}
    /**
     * Convert a component to a string
     * @param segment	The segment
     * @param fieldNo	The field
     * @param component	The component
     * @return	The component converted to a string
     */
	public static String toString(Segment segment, int fieldNo, int component) {
<span class="fc" id="L133">		Type t = getField(segment, fieldNo);</span>
<span class="fc" id="L134">		t = DatatypeConverter.adjustIfVaries(t);</span>
<span class="fc bfc" id="L135" title="All 2 branches covered.">		if (t instanceof Composite comp) {</span>
<span class="fc" id="L136">			return toString(comp.getComponents(), component);</span>
		} 
<span class="pc bpc" id="L138" title="1 of 2 branches missed.">		if (component == 1) {</span>
<span class="nc" id="L139">			return toString(t);</span>
		}
		// Components beyond 1 don't exist in a primitive
		// This happens in cases where field changes between versions,
		// so a 2.8.1 message might have a SEG-3-2, but in prior versions,
		// SEG-3 only had a primitive type.
<span class="fc" id="L145">		return null;</span>
	}

	/**
     * Convert a component of a HAPI V2 datatype to a String
     * @param types Components of the composite type to convert
     * @param i The index of the component to convert
     * @return The string conversion
     */
	public static String toString(Type[] types, int i) {
<span class="fc bfc" id="L155" title="All 2 branches covered.">		return types.length &gt; i ? toString(types[i]) : &quot;&quot;;</span>
		
	}
	/**
     * Convert a HAPI V2 Composite component to a String
     * @param v2Type The composite type containing the component to convert
     * @param i The index of the component to convert
     * @return The string conversion
     */
	public static String toString(Composite v2Type, int i) {
<span class="pc bpc" id="L165" title="1 of 2 branches missed.">		if (v2Type == null) {</span>
<span class="nc" id="L166">			return &quot;&quot;;</span>
		}
<span class="fc" id="L168">		return toString(v2Type.getComponents(), i);</span>
	}
	
	/**
     * Convert a HAPI V2 Composite subcomponent to a String
     * @param v2Type The composite type containing the subcomponent to convert
     * @param i The index of the component to convert
     * @param j The index of the subcomponent within the component to convert
     * @return The string conversion
     */
	public static String toString(Composite v2Type, int i, int j) {
<span class="pc bpc" id="L179" title="1 of 2 branches missed.">		if (v2Type == null) {</span>
<span class="nc" id="L180">			return &quot;&quot;;</span>
		}
		
<span class="fc" id="L183">		Type[] types = v2Type.getComponents();</span>
<span class="pc bpc" id="L184" title="1 of 2 branches missed.">		Type t = types.length &gt; i ? types[i] : null;</span>
<span class="pc bpc" id="L185" title="1 of 2 branches missed.">		if (t instanceof Varies v) {</span>
<span class="nc" id="L186">			t = v.getData();</span>
		}
<span class="pc bpc" id="L188" title="1 of 2 branches missed.">		if (t instanceof Composite comp) {</span>
<span class="fc" id="L189">			return toString(comp, j);</span>
		}
<span class="nc" id="L191">		return toString(t);</span>
	}

	/**
     * Convert HAPI V2 Composite components to an array of Strings
     * @param v2Type The composite type containing the components to convert
     * @param locations The locations within the component to convert
     * @return The string conversion
     */

	public static String[] toStrings(Composite v2Type, int ...locations) {
<span class="fc" id="L202">		String[] strings = new String[locations.length];</span>
		
<span class="fc" id="L204">		Type[] types = v2Type.getComponents();</span>
<span class="fc bfc" id="L205" title="All 2 branches covered.">		for (int i = 0; i &lt; locations.length; i++) {</span>
<span class="fc bfc" id="L206" title="All 2 branches covered.">			if (locations[i] &lt; types.length) {</span>
<span class="fc" id="L207">				strings[i] = toString(v2Type, locations[i]);</span>
			}
		}
<span class="fc" id="L210">		return strings;</span>
	}
	
	/**
	 * Detect (without exceptions) if HAPI V2 type is empty
	 * @param type	The type to check
	 * @return true if the component is empty or throws an exception, false if it has data.
	 */
	public static boolean isEmpty(Type type) {
		try {
<span class="fc" id="L220">			return type.isEmpty();</span>
<span class="nc" id="L221">		} catch (HL7Exception e) {</span>
<span class="nc" id="L222">			warn(UNEXPECTED_HL7_EXCEPTION, e.getMessage(), e);</span>
<span class="nc" id="L223">			return true;</span>
		}
	}
	
	/**
	 * Convert an ISO-8601 string to one with punctuation
	 * @param value	The string to cleanup
	 * @param hasDate True if this string has a date, false if just the time
	 * @return	The cleaned up ISO-8601 string suitable for use in FHIR
	 */
	public static String cleanupIsoDateTime(String value, boolean hasDate) {
<span class="pc bpc" id="L234" title="2 of 4 branches missed.">		if (StringUtils.substringBefore(value, &quot;.&quot;).length() &lt; (hasDate ? 4 : 2)) {</span>
<span class="nc" id="L235">			return null;</span>
		}
<span class="pc bpc" id="L237" title="1 of 2 branches missed.">		if (!hasLegalIso8601Chars(value, hasDate)) {</span>
<span class="nc" id="L238">			return null;</span>
		}
<span class="fc" id="L240">		StringReader r = new StringReader(value.trim());</span>
<span class="fc" id="L241">		StringBuilder b = new StringBuilder();</span>
<span class="fc" id="L242">		int[] data = { 4, '-', 2, '-', 2, 'T', 2, ':', 2, ':', 2, '.', 6, '+', 2, ':', 2 };</span>
<span class="fc" id="L243">		int c = 0;</span>
<span class="pc bpc" id="L244" title="1 of 2 branches missed.">		int state = hasDate ? 0 : 6;</span>
		try {
<span class="fc bfc" id="L246" title="All 4 branches covered.">			while (state &lt; data.length &amp;&amp; (c = r.read()) &gt;= 0) {</span>
<span class="pc bpc" id="L247" title="1 of 2 branches missed.">				if (Character.isWhitespace(c)) {</span>
<span class="nc" id="L248">					continue;</span>
				}
<span class="fc bfc" id="L250" title="All 2 branches covered.">				if (data[state] &lt; ' ') {  </span>
<span class="fc" id="L251">					state = getIsoDigits(b, data, c, state);</span>
				} else {
<span class="fc" id="L253">					state = getIsoPunct(b, data, c, state);</span>
				}
			}
<span class="pc bpc" id="L256" title="1 of 4 branches missed.">			if (c &lt; 0 || r.read() &lt; 0) {</span>
<span class="fc" id="L257">				return b.toString();</span>
			}
<span class="nc" id="L259">		} catch (IOException e) {</span>
			// Not going to happen on StringReader.
<span class="nc" id="L261">		}</span>
		// We finished reading, but there was more data.
<span class="nc" id="L263">		return null;</span>
	}
	
	/**
	 * Check to see if a string contains only legal counts of ISO-8601 characters
	 * @param value	The string to check
	 * @param hasDate True if this string has a date, false if just the time
	 * @return	True if the string looks like an ISO-8601 string, false otherwise.
	 */
	
	public static boolean hasLegalIso8601Chars(String value, boolean hasDate) {
		// Check for legal ISO characters
<span class="pc bpc" id="L275" title="1 of 2 branches missed.">		String legalChars = hasDate ? &quot;0123456789T:-+.Z&quot; : &quot;0123456789:-+.Z&quot;;</span>
<span class="pc bpc" id="L276" title="1 of 2 branches missed.">		if (!StringUtils.containsOnly(value, legalChars)) {</span>
<span class="nc" id="L277">			return false;</span>
		}
		// Check for legal number of ISO punctuation characters
<span class="pc bpc" id="L280" title="1 of 2 branches missed.">		if (StringUtils.countMatches(value, 'T') &gt; 1 ||  // NOSONAR This style is more readable</span>
<span class="pc bpc" id="L281" title="1 of 2 branches missed.">			StringUtils.countMatches(value, '.') &gt; 1 ||</span>
<span class="pc bpc" id="L282" title="1 of 2 branches missed.">			StringUtils.countMatches(value, '+') &gt; 1 ||</span>
<span class="pc bpc" id="L283" title="1 of 2 branches missed.">			StringUtils.countMatches(value, '-') &gt; 3 ||</span>
<span class="pc bpc" id="L284" title="1 of 2 branches missed.">			StringUtils.countMatches(value, ':') &gt; 3) {</span>
<span class="nc" id="L285">			return false;</span>
		}
<span class="fc" id="L287">		return true;</span>
	}

	private static int getIsoDigits(StringBuilder b, int[] data, int c, int state) {
		// We are Looking for digits
<span class="fc bfc" id="L292" title="All 2 branches covered.">		if (Character.isDigit(c)) {</span>
<span class="fc" id="L293">			b.append((char)c);</span>
<span class="fc bfc" id="L294" title="All 2 branches covered.">			if (--data[state] == 0) {</span>
<span class="fc" id="L295">				state++;</span>
			}
<span class="pc bpc" id="L297" title="1 of 2 branches missed.">		} else if (state + 1 == data.length) {</span>
			// We've finished this, but we have an unexpected character
<span class="nc" id="L299">			b.append((char)c);</span>
<span class="nc" id="L300">			state++;</span>
<span class="pc bpc" id="L301" title="5 of 6 branches missed.">		} else if (data[state + 1] == c || (data[state + 1] == '+' &amp;&amp; c == '-')) {</span>
			// We got the separator early, append it and advance two states
<span class="fc" id="L303">			b.append((char)c);</span>
<span class="fc" id="L304">			state += 2;</span>
		}
<span class="fc" id="L306">		return state;</span>
	}
	
	private static int getIsoPunct(StringBuilder b, int[] data, int c, int state) {
<span class="fc bfc" id="L310" title="All 2 branches covered.">		if (c == data[state]) { </span>
			// Waiting on punctuation and we got it
<span class="fc" id="L312">			b.append((char)c);</span>
<span class="pc bpc" id="L313" title="1 of 2 branches missed.">			if (c == 'Z') {</span>
<span class="nc" id="L314">				state = data.length; // We're done.</span>
			}
<span class="fc" id="L316">			state++;</span>
<span class="fc bfc" id="L317" title="All 4 branches covered.">		} else if (state &gt; 5 &amp;&amp; &quot;+-Z&quot;.indexOf(c) &gt;= 0 ) {</span>
			// Timezone can show up early
<span class="fc" id="L319">			b.append((char)c);</span>
<span class="fc" id="L320">			state = 14;</span>
<span class="pc bpc" id="L321" title="1 of 2 branches missed.">		} else if ((char)c == '.') {</span>
			// Decimal can show up early
<span class="nc" id="L323">			b.append((char)c);</span>
<span class="nc" id="L324">			state = 12;</span>
<span class="pc bpc" id="L325" title="1 of 2 branches missed.">		} else if (Character.isDigit(c)) {</span>
			// We got a digit while waiting on punctuation
<span class="fc" id="L327">			b.append((char)data[state]);</span>
<span class="fc" id="L328">			++state;</span>
<span class="fc" id="L329">			b.append((char)c);</span>
<span class="fc" id="L330">			--data[state];</span>
		}
<span class="fc" id="L332">		return state;</span>
	}
	
	/**
	 * Given a string containing escaped HL7 Version 2 characters, translate them
	 * to the standard values.
	 * 
	 * @param value	The string to translated
	 * @return	The translated string
	 */
	public static String unescapeV2Chars(String value) {
<span class="fc" id="L343">		value = value.replace(&quot;\\F\\&quot;, &quot;|&quot;);</span>
<span class="fc" id="L344">		value = value.replace(&quot;\\S\\&quot;, &quot;^&quot;);</span>
<span class="fc" id="L345">		value = value.replace(&quot;\\R\\&quot;, &quot;~&quot;);</span>
<span class="fc" id="L346">		value = value.replace(&quot;\\T\\&quot;, &quot;&amp;&quot;);</span>
<span class="fc" id="L347">		value = value.replace(&quot;\\E\\&quot;, &quot;\\&quot;);</span>
<span class="fc" id="L348">		return value;</span>
	}
	
	/**
	 * Given a string possibly containing V2 reserved characters, translate
	 * the reserved characters to their standard escape sequences.
	 * 
	 * @param value	The string to escape
	 * @return	The escaped string
	 */
	public static String escapeV2Chars(String value) {
<span class="nc" id="L359">		value = value.replace(&quot;\\&quot;, &quot;\\E\\&quot;);</span>
<span class="nc" id="L360">		value = value.replace(&quot;|&quot;, &quot;\\F\\&quot;);</span>
<span class="nc" id="L361">		value = value.replace(&quot;^&quot;, &quot;\\S\\&quot;);</span>
<span class="nc" id="L362">		value = value.replace(&quot;~&quot;, &quot;\\R\\&quot;);</span>
<span class="nc" id="L363">		value = value.replace(&quot;&amp;&quot;, &quot;\\T\\&quot;);</span>
<span class="nc" id="L364">		return value;</span>
	}
	
	/**
	 * Iterate over a set of structures and add them to a set
	 * 
	 * This is primarily used by testing components to get a set of segments
	 * for testing from test messages, by may also be useful in StructureParser objects
	 * to enumerate the message components in a message or group.
	 *  
	 * NOTE: Use a LinkedHashSet to get the structures in order.
	 * 
	 * @param g	The group to traverse
	 * @param structures The set of structures to add to.
	 */
	public static void iterateStructures(Group g, Set&lt;Structure&gt; structures) {
<span class="pc bpc" id="L380" title="1 of 2 branches missed.">		if (g == null) {</span>
<span class="nc" id="L381">			return;</span>
		}
<span class="fc bfc" id="L383" title="All 2 branches covered.">		for (String name: g.getNames()) {</span>
			try {
<span class="fc bfc" id="L385" title="All 2 branches covered.">				for (Structure s: g.getAll(name)) {</span>
<span class="fc bfc" id="L386" title="All 2 branches covered.">					if (s instanceof Segment seg) {</span>
<span class="fc" id="L387">						structures.add(seg);</span>
<span class="pc bpc" id="L388" title="1 of 2 branches missed.">					} else if (s instanceof Group group) {</span>
<span class="fc" id="L389">						structures.add(s);</span>
<span class="fc" id="L390">						iterateStructures(group, structures);</span>
					}
				}
<span class="nc" id="L393">			} catch (HL7Exception e) {</span>
<span class="nc" id="L394">				log.warn(&quot;Unexpected HL7Exception iterating structures: {}&quot;, e.getMessage(), e);</span>
<span class="fc" id="L395">			}</span>
		}
<span class="fc" id="L397">	}</span>
	
	/**
	 * Iterate over a set of structures and the segments within them to a set
	 * 
	 * This is primarily used by testing components to get a set of segments
	 * for testing from test messages, by may also be useful in StructureParser objects
	 * to enumerate the message components in a message or group.
	 *  
	 * NOTE: Use a LinkedHashSet to get the segments in order.
	 * 
	 * @see #iterateStructures(Group, Set)
	 * @param g	The group to traverse
	 * @param structures The set of structures to add to.
	 */
	public static void iterateSegments(Group g, Set&lt;Segment&gt; structures) {
<span class="pc bpc" id="L413" title="1 of 2 branches missed.">		if (g == null) {</span>
<span class="nc" id="L414">			return;</span>
		}
<span class="fc bfc" id="L416" title="All 2 branches covered.">		for (String name: g.getNames()) {</span>
			try {
<span class="fc bfc" id="L418" title="All 2 branches covered.">				for (Structure s: g.getAll(name)) {</span>
<span class="fc bfc" id="L419" title="All 2 branches covered.">					if (s instanceof Segment seg) {</span>
<span class="fc" id="L420">						structures.add(seg);</span>
<span class="pc bpc" id="L421" title="1 of 2 branches missed.">					} else if (s instanceof Group group) {</span>
<span class="fc" id="L422">						iterateSegments(group, structures);</span>
					}
				}
<span class="nc" id="L425">			} catch (HL7Exception e) {</span>
<span class="nc" id="L426">				log.error(UNEXPECTED_HL7_EXCEPTION, e.getMessage(), e);</span>
<span class="fc" id="L427">			}</span>
		}
<span class="fc" id="L429">	}</span>

	/**
	 * Get a component from a composite
	 * @param type	The composite to get the component from
	 * @param number The zero-indexed component to get 
	 * @return	The component, or null if type doesn't represent a Composite 
	 */
	public static Type getComponent(Type type, int number) {
<span class="pc bpc" id="L438" title="1 of 2 branches missed.">		if (type instanceof Varies v) {</span>
<span class="nc" id="L439">			type = v.getData();</span>
		}
<span class="pc bpc" id="L441" title="1 of 2 branches missed.">		if (type instanceof Composite comp) {</span>
<span class="fc" id="L442">			Type[] a = comp.getComponents();</span>
<span class="pc bpc" id="L443" title="1 of 2 branches missed.">			return number &lt; a.length ? a[number] : null;</span>
		}
<span class="nc bnc" id="L445" title="All 2 branches missed.">		if (number == 0) {</span>
			// This handles the case of requesting the first component of what used to
			// be a primitive, but is now a composite in a later version of the standard.
<span class="nc" id="L448">			return type;</span>
		}
		// warn(&quot;{}-{} is not a composite&quot;, type.getName(), number, type)
<span class="nc" id="L451">		return null;</span>
	}
	
	/**
	 * Get the first occurrence of a field in a segment, nor null if it does not exist or an exception is
	 * thrown.
	 * 
	 * @param segment	The segment to get the field from
	 * @param field	The zero-index field number
	 * @return	The first occurence of the field
	 */
	public static Type getField(Segment segment, int field) {
		try {
<span class="fc" id="L464">			Type[] types = segment.getField(field); </span>
<span class="pc bpc" id="L465" title="1 of 4 branches missed.">			if (types == null || types.length == 0) {</span>
<span class="fc" id="L466">				return null;</span>
			}
<span class="pc bpc" id="L468" title="2 of 4 branches missed.">			if (types[0] == null || types[0].isEmpty()) {</span>
<span class="nc" id="L469">				return null;</span>
			}
<span class="fc" id="L471">			return types[0];</span>
<span class="nc" id="L472">		} catch (HL7Exception e) {</span>
<span class="nc" id="L473">			return null;</span>
		} 
	}
	
	/**
	 * Get the all occurrences of a field in a segment, nor null if it does not exist or an exception is
	 * thrown.
	 * 
	 * @param segment	The segment to get the field from
	 * @param field	The zero-index field number
	 * @return	The fields
	 */
	public static Type[] getFields(Segment segment, int field) {
		try {
<span class="fc" id="L487">			Type[] types = segment.getField(field); </span>
<span class="pc bpc" id="L488" title="1 of 4 branches missed.">			if (types == null || types.length == 0) {</span>
<span class="fc" id="L489">				return new Type[0];</span>
			}
<span class="fc" id="L491">			return types;</span>
<span class="nc" id="L492">		} catch (HL7Exception e) {</span>
<span class="nc" id="L493">			return new Type[0];</span>
		} 
	}
	
	/**
	 * Test if a segment has a value in a given field
	 * @param segment	The segment to test
	 * @param field		The field to look for
	 * @return	true if the field is present, false otherwise
	 */
	public static  boolean hasField(Segment segment, int field) {
<span class="nc bnc" id="L504" title="All 2 branches missed.">		return getField(segment, field) != null;</span>
	}

	/**
	 * Get the type of a field in a segment
	 * 
	 * Used in path conversions to determine the type of a component
	 * 
	 * @param segment	The segment to check
	 * @param number	The field within the segment
	 * @return The first occurrence of the field
	 */
	public static Type getFieldType(String segment, int number) {
<span class="nc" id="L517">		Segment seg = getSegment(segment);</span>
<span class="nc bnc" id="L518" title="All 2 branches missed.">		if (seg == null) {</span>
<span class="nc" id="L519">			return null;</span>
		}
		try {
<span class="nc" id="L522">			return seg.getField(number, 0);</span>
<span class="nc" id="L523">		} catch (HL7Exception e) {</span>
<span class="nc" id="L524">			warn(&quot;Unexpected {} {}: {}&quot;, e.getClass().getSimpleName(), segment, e.getMessage(), e);</span>
		}
<span class="nc" id="L526">		return null;</span>
	}
	/**
	 * The the class representing the specified segment type
	 * 
	 * Classes are taken preferentially from HAPI V2 2.8.1 models, but some withdrawn classes will
	 * come from earlier model versions (usually HAPI V2 2.5.1).
	 * 
	 * @param segment	The HL7 V2 segment name
	 * @return	A HAPI V2 class representing the segment.
	 */
	private static Class&lt;Segment&gt; getSegmentClass(String segment) {
<span class="nc" id="L538">		String name = null;</span>
<span class="nc" id="L539">		Exception saved = null;</span>
<span class="nc bnc" id="L540" title="All 2 branches missed.">		for (Class&lt;?&gt; errClass : Arrays.asList(ca.uhn.hl7v2.model.v281.segment.ERR.class, ca.uhn.hl7v2.model.v251.segment.ERR.class)) {</span>
<span class="nc" id="L541">			name = errClass.getPackageName() +  segment;</span>
			try {
				@SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L544">				Class&lt;Segment&gt; clazz = (Class&lt;Segment&gt;) ClassLoader.getSystemClassLoader().loadClass(name);</span>
<span class="nc" id="L545">				return clazz;</span>
<span class="nc" id="L546">			} catch (ClassNotFoundException e) {</span>
<span class="nc" id="L547">				saved = e;</span>
			}
<span class="nc" id="L549">		}</span>
<span class="nc bnc" id="L550" title="All 2 branches missed.">		if (saved != null) {</span>
<span class="nc" id="L551">			warn(&quot;Unexpected {} loading {}: {}&quot;, saved.getClass().getSimpleName(), segment, saved.getMessage(), saved);</span>
		}
<span class="nc" id="L553">		return null;</span>
	}
	
	/**
	 * Create a segment of the specified type
	 * @param segment	The type of segment to create 
	 * @return	The constructed segment, or null if the segment type is unknown.
	 */
	public static Segment getSegment(String segment) {
<span class="nc" id="L562">		Class&lt;Segment&gt; segClass = getSegmentClass(segment);</span>
<span class="nc bnc" id="L563" title="All 2 branches missed.">		if (segClass == null) {</span>
<span class="nc" id="L564">			return null;</span>
		}
		try {
<span class="nc" id="L567">			return segClass.getDeclaredConstructor(Message.class).newInstance((Message)null);</span>
<span class="nc" id="L568">		} catch (InstantiationException | IllegalAccessException | IllegalArgumentException</span>
				| InvocationTargetException | NoSuchMethodException | SecurityException e) {
<span class="nc" id="L570">			warn(&quot;Unexpected {} loading {}&quot;, e.getClass().getSimpleName(), segClass.getName(), e);</span>
<span class="nc" id="L571">			return null;</span>
		}
	}
	
	
	/**
	 * Create or get the existing reference for a resource.  
	 *
	 * Every resource has a singular reference returned by this method. This 
	 * ensures the reference is consistent across all uses based on the 
	 * values in the resource such as identifier, and name.
	 * 
	 * Set the reference id to the resource id, and make this reference point 
	 * to the resource through getResource().
	 * 
	 * @see #getResource(Class, Reference)
	 * @param resource	The resource to create the reference to
	 * @param source	The resource which points to the newly created reference
	 * @param searchNames The name used to reference this from the source 
	 * @return	The created Reference
	 */
	public static Reference toReference(Resource resource, Resource source, String ... searchNames) {
<span class="fc" id="L593">		Reference ref = createReferenceWithSearch(resource, SEARCH_NAMES, searchNames);</span>

<span class="fc bfc" id="L595" title="All 2 branches covered.">		if (source != null) {</span>
			// Track forward references
<span class="fc" id="L597">			addIncludeReferences(source, ref, true);</span>
			
			// Track Reverse references
<span class="fc" id="L600">			Reference rev = createReferenceWithSearch(source, REVERSE_NAMES, searchNames);</span>
<span class="fc" id="L601">			addIncludeReferences(resource, rev, false);</span>
		}
		
<span class="fc" id="L604">		return ref;</span>
	}
	
	/**
	 * Make the references to a later resource point to the first resource instead.
	 * Enables merging of two resources into one.
	 * 
	 * @param first	The first resource
	 * @param later	The later resource
	 */
	public static void mergeReferences(Resource first, Resource later) {
<span class="fc" id="L615">		Reference fRef = (Reference) first.getUserData(REFERENCE_LINK);</span>
<span class="fc" id="L616">		Reference lRef = (Reference) later.getUserData(REFERENCE_LINK);</span>
		
<span class="pc bpc" id="L618" title="2 of 4 branches missed.">		if (fRef == null || lRef == null) {</span>
<span class="nc" id="L619">			return;</span>
		}
		
<span class="fc" id="L622">		lRef.setReferenceElement(fRef.getReferenceElement());</span>
		// If the first reference doesn't have an identifier, copy the identifier
		// from lRef into it.
<span class="pc bpc" id="L625" title="1 of 2 branches missed.">		if (fRef.getIdentifier() == null) {</span>
<span class="nc" id="L626">			fRef.setIdentifier(lRef.getIdentifier());</span>
		}
<span class="pc bpc" id="L628" title="1 of 2 branches missed.">		if (lRef.getIdentifier() == null) {</span>
<span class="nc" id="L629">			lRef.setIdentifier(fRef.getIdentifier());</span>
		}
		// The two references should now look identical, and will both point
		// to the first resource.
		
		/*
		 * TODO: Merge the searchNames and reverseNames fields.
		 * searchNames 
		 */
		
<span class="fc" id="L639">		updateReference(first, fRef);</span>
<span class="fc" id="L640">		updateReference(later, lRef);</span>
<span class="fc" id="L641">	}</span>

	private static Reference createReferenceWithSearch(Resource resource, String userDataNamesField, String ...searchNames) {
<span class="pc bpc" id="L644" title="1 of 2 branches missed.">		if (resource == null) {</span>
<span class="nc" id="L645">			throw new NullPointerException(&quot;Resource cannot be null&quot;);</span>
		}
<span class="fc" id="L647">		Reference ref = createReference(resource);</span>
<span class="fc" id="L648">		addSearchNames(ref, userDataNamesField, searchNames);</span>
<span class="fc" id="L649">		updateReference(resource, ref);</span>
<span class="fc" id="L650">		return ref;</span>
	}

	private static Reference createReference(Resource resource) {
<span class="fc" id="L654">		Reference ref = (Reference) resource.getUserData(REFERENCE_LINK);</span>
		
<span class="fc bfc" id="L656" title="All 2 branches covered.">		if (ref == null) {</span>
<span class="fc" id="L657">			ref = new Reference();</span>
			// Link the resource to the reference
<span class="fc" id="L659">			resource.setUserData(REFERENCE_LINK, ref);</span>
			// And the reference to the resource
<span class="fc" id="L661">			ref.setUserData(&quot;Resource&quot;, resource);</span>
<span class="fc" id="L662">			ref.setResource(resource);</span>
		}
		
<span class="fc" id="L665">		IdType id = resource.getIdElement();</span>
<span class="pc bpc" id="L666" title="1 of 2 branches missed.">		if (id != null) {</span>
<span class="fc" id="L667">			ref.setReferenceElement(id);</span>
		}
		
<span class="fc" id="L670">		return ref;</span>
	}

	/**
	 * Make references nicer by adding an identifier and display
	 * properties, but don't overwrite any existing ones.
	 * 
	 * Essentially, the first referencing improving property
	 * is set, but no further ones will be added.
	 * 
	 * @param resource	The resource the reference points to
	 * @param ref	The reference to update.
	 */
	public static void updateReference(Resource resource, Reference ref) {
		// Make very nice references by adding identifier and display
		
		// We take advantage of some polymorphic HAPI FHIR capabilities
		// to get attributes with common names to get the identifier and name 
		// from the resource.
<span class="fc bfc" id="L689" title="All 2 branches covered.">		if (!ref.hasIdentifier()) {</span>
<span class="fc" id="L690">			Identifier ident = (Identifier) getFirstChild(resource, &quot;identifier&quot;);</span>
<span class="fc bfc" id="L691" title="All 2 branches covered.">			if (ident != null) {</span>
<span class="fc" id="L692">				ref.setIdentifier(ident);</span>
			}
		}
		
		// Don't break the reference's display if it already has one.  First name
		// in is kept.
<span class="fc bfc" id="L698" title="All 2 branches covered.">		if (!ref.hasDisplay()) {</span>
<span class="fc" id="L699">			IBase name = getFirstChild(resource, &quot;name&quot;);</span>
			// don't write out a useless display value.
<span class="pc bpc" id="L701" title="1 of 4 branches missed.">			if (name != null &amp;&amp; !name.isEmpty()) {</span>
<span class="fc bfc" id="L702" title="All 2 branches covered.">				if (name instanceof HumanName hn) {</span>
<span class="fc" id="L703">					ref.setDisplay(TextUtils.toText(hn));</span>
<span class="pc bpc" id="L704" title="1 of 2 branches missed.">				} else if (name instanceof StringType st) {</span>
<span class="fc" id="L705">					ref.setDisplayElement(st);</span>
				}
			}
		}
<span class="fc" id="L709">	}</span>

	private static void addIncludeReferences(Resource resource, Reference ref, boolean isForward) {
<span class="fc bfc" id="L712" title="All 2 branches covered.">		String direction = isForward ? &quot;References&quot; : &quot;Reverses&quot;;</span>
		@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L714">		Set&lt;Reference&gt; refs = (Set&lt;Reference&gt;) resource.getUserData(direction);</span>
<span class="fc bfc" id="L715" title="All 2 branches covered.">		if (refs == null) {</span>
<span class="fc" id="L716">			refs = new LinkedHashSet&lt;&gt;();</span>
<span class="fc" id="L717">			resource.setUserData(direction, refs);</span>
		}
<span class="fc" id="L719">		refs.add(ref);</span>
<span class="fc" id="L720">	}</span>

	private static void addSearchNames(Reference ref, String userDataNamesField, String... searchNames) {
<span class="fc bfc" id="L723" title="All 2 branches covered.">		for (String searchName: searchNames) {</span>
<span class="fc" id="L724">			String names = ref.getUserString(userDataNamesField);</span>
<span class="fc bfc" id="L725" title="All 2 branches covered.">			if (names == null) {</span>
<span class="fc" id="L726">				ref.setUserData(userDataNamesField, searchName);</span>
			} else {
<span class="fc bfc" id="L728" title="All 2 branches covered.">				if (!Arrays.asList(names.split(&quot;,&quot;)).contains(searchName)) {</span>
<span class="fc" id="L729">					names += &quot;,&quot; + searchName;</span>
				}
<span class="fc" id="L731">				ref.setUserData(userDataNamesField, names);</span>
			}
		}
<span class="fc" id="L734">	}</span>
		

	/**
	 * Get the resource linked to this reference.  This method can be used on the 
	 * reference returned by toReference.
	 * 
	 * @see #toReference(DomainResource, Resource, String...)
	 * 
	 * @param &lt;T&gt;	The class of the resource
	 * @param clazz	The class
	 * @param ref	The reference
	 * @return	The resource linked to the reference.
	 */
	public static &lt;T extends IBaseResource&gt; T getResource(Class&lt;T&gt; clazz, Reference ref) {
<span class="fc" id="L749">		return clazz.cast(ref.getUserData(&quot;Resource&quot;));</span>
	}


	/**
	 * Get the first child of the specified name
	 * @param r	The resource
	 * @param name	The name of the property
	 * @return	The value of the property
	 */
	public static IBase getFirstChild(Resource r, String name) {
<span class="fc" id="L760">		Property p = r.getChildByName(name);</span>
<span class="fc bfc" id="L761" title="All 4 branches covered.">		if (p == null || p.getValues().isEmpty()) {</span>
<span class="fc" id="L762">			return null;</span>
		}
<span class="fc" id="L764">		return p.getValues().get(0);</span>
	}
	
	private static void warn(String msg, Object ...args) {
<span class="nc" id="L768">		log.warn(msg, args);</span>
<span class="nc" id="L769">	}</span>

	/**
	 * Return true if this datatypes string representation is of a date type 
	 * and therefore needs to be restated to ISO with punctuation.
	 * @param t	The data type
	 * @return	true if cleanup is needed.
	 */
	public static Boolean needsIsoCleanup(Type t) {
<span class="fc" id="L778">		String typeName = t.getName();</span>
<span class="pc bpc" id="L779" title="1 of 3 branches missed.">		switch (typeName) {</span>
<span class="nc" id="L780">		case &quot;TM&quot;: return Boolean.FALSE;</span>
		case &quot;DIN&quot;, &quot;DLD&quot;, &quot;DR&quot;, &quot;DT&quot;, &quot;DTM&quot;: 
<span class="fc" id="L782">			return Boolean.TRUE;</span>
		default:
<span class="fc" id="L784">			return null;  // NOSONAR null = No cleanup needed</span>
		}
	}

	/**
	 * Given a segment, find the segment following it with the given name.
	 * Stops at the end of the group the segment is in, or once it finds
	 * a repetition of the same original segment.
	 * @param segment	The segment to start the search from.
	 * @param findName	The segment type to find
	 * @return	The found segment, or null of it could not be found.
	 */
	public static Segment getFollowingSegment(Segment segment, String findName) {
<span class="nc" id="L797">		Segment found = null;</span>
<span class="nc" id="L798">		String myName = segment.getName();</span>
		// We've got some segment, get to the immediately following segment in findName
		try {
<span class="nc" id="L801">			Group g = segment.getParent();</span>
<span class="nc bnc" id="L802" title="All 2 branches missed.">			if (g == null) {</span>
<span class="nc" id="L803">				return null;</span>
			}
			
<span class="nc" id="L806">			boolean foundMe = false;</span>
<span class="nc bnc" id="L807" title="All 2 branches missed.">			for (String name: g.getNames()) {</span>
<span class="nc bnc" id="L808" title="All 2 branches missed.">				if (!foundMe) {</span>
<span class="nc bnc" id="L809" title="All 4 branches missed.">					foundMe = name.startsWith(myName) &amp;&amp; g.get(name) == segment;</span>
<span class="nc" id="L810">					continue;</span>
				}
				
<span class="nc bnc" id="L813" title="All 2 branches missed.">				if (name.startsWith(findName)) {</span>
<span class="nc" id="L814">					found = (Segment)g.get(name);</span>
<span class="nc" id="L815">					break;</span>
				} 
				
<span class="nc bnc" id="L818" title="All 2 branches missed.">				if (name.startsWith(myName)) {</span>
<span class="nc" id="L819">					break;</span>
				}
			}
<span class="nc" id="L822">		} catch (HL7Exception e) {</span>
<span class="nc" id="L823">			log.warn(UNEXPECTED_HL7_EXCEPTION, e.getMessage(), e);</span>
<span class="nc" id="L824">		}</span>
<span class="nc" id="L825">		return found;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>