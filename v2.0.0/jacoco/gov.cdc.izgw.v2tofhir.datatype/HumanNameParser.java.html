<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>HumanNameParser.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">HL7 Version 2 to FHIR Conversion</a> &gt; <a href="index.source.html" class="el_package">gov.cdc.izgw.v2tofhir.datatype</a> &gt; <span class="el_source">HumanNameParser.java</span></div><h1>HumanNameParser.java</h1><pre class="source lang-java linenums">package gov.cdc.izgw.v2tofhir.datatype;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.apache.commons.lang3.StringUtils;
import org.hl7.fhir.r4.model.HumanName;
import org.hl7.fhir.r4.model.HumanName.NameUse;
import org.hl7.fhir.r4.model.StringType;

import ca.uhn.hl7v2.model.Composite;
import ca.uhn.hl7v2.model.Primitive;
import ca.uhn.hl7v2.model.Type;
import gov.cdc.izgw.v2tofhir.converter.DatatypeConverter;
import gov.cdc.izgw.v2tofhir.utils.ParserUtils;

/**
 * Parser for Human Names.
 */
public class HumanNameParser implements DatatypeParser&lt;HumanName&gt; {
	/** Name prefixes appearing before the given name */
<span class="fc" id="L25">	public static final Set&lt;String&gt; PREFIXES = Collections.unmodifiableSet(new HashSet&lt;&gt;(Arrays.asList(&quot;mr&quot;, &quot;mrs&quot;, &quot;miss&quot;, &quot;sr&quot;, &quot;br&quot;, &quot;fr&quot;, &quot;dr&quot;)));</span>
	/** Name suffixes appearing after the surname (family) name */
<span class="fc" id="L27">	public static final Set&lt;String&gt; SUFFIXES = Collections.unmodifiableSet(new HashSet&lt;&gt;(Arrays.asList(&quot;jr&quot;, &quot;sr&quot;, &quot;i&quot;, &quot;ii&quot;, &quot;iii&quot;, &quot;iv&quot;, &quot;v&quot;)));</span>
	/** An affix is a prefix to a family name
	 * See https://en.wikipedia.org/wiki/List_of_family_name_affixes
	 */
<span class="fc" id="L31">	public static final Set&lt;String&gt; AFFIXES = Collections.unmodifiableSet(new HashSet&lt;&gt;(Arrays.asList(&quot;Abu&quot;, &quot;al&quot;, &quot;bet&quot;, &quot;bint&quot;, &quot;el&quot;, &quot;ibn&quot;, &quot;ter&quot;,</span>
			&quot;fer&quot;, &quot;ait&quot;, &quot;a\u00eft&quot;, &quot;at&quot;, &quot;ath&quot;, &quot;de&quot;, &quot;'s&quot;, &quot;'t&quot;, &quot;ter&quot;, &quot;van&quot;, &quot;vande&quot;, &quot;vanden&quot;, &quot;vander&quot;, &quot;van't&quot;,
			&quot;von&quot;, &quot;bath&quot;, &quot;bat&quot;, &quot;ben&quot;, &quot;bin&quot;, &quot;del&quot;, &quot;degli&quot;, &quot;della&quot;, &quot;di&quot;, &quot;a&quot;, &quot;ab&quot;, &quot;ap&quot;, &quot;ferch&quot;, &quot;verch&quot;,
			&quot;verch&quot;, &quot;erch&quot;, &quot;af&quot;, &quot;alam&quot;, &quot;\u0101lam&quot;, &quot;bar&quot;, &quot;ch&quot;, &quot;chaudhary&quot;, &quot;da&quot;, &quot;das&quot;, &quot;de&quot;, &quot;dele&quot;, &quot;dos&quot;,
			&quot;du&quot;, &quot;e&quot;, &quot;fitz&quot;, &quot;i&quot;, &quot;ka&quot;, &quot;kil&quot;, &quot;gil&quot;, &quot;mal&quot;, &quot;mul&quot;, &quot;la&quot;, &quot;le&quot;, &quot;lu&quot;, &quot;m'&quot;, &quot;mac&quot;, &quot;mc&quot;, &quot;mck&quot;,
			&quot;mhic&quot;, &quot;mic&quot;, &quot;mala&quot;, &quot;na&quot;, &quot;nga&quot;, &quot;ng\u0101&quot;, &quot;nic&quot;, &quot;ni&quot;, &quot;n\u00ed&quot;, &quot;nin&quot;, &quot;o&quot;, &quot;\u00f3&quot;, &quot;ua&quot;, &quot;ui&quot;,
			&quot;u\u00ed&quot;, &quot;oz&quot;, &quot;\u00f6z&quot;, &quot;pour&quot;, &quot;te&quot;, &quot;tre&quot;, &quot;war&quot;)));
	/** Professional suffixes appearing after the surname (family) and any other suffixes */
<span class="fc" id="L39">	public static final Set&lt;String&gt; DEGREES = Collections.unmodifiableSet(new HashSet&lt;&gt;(Arrays.asList(&quot;ab&quot;, &quot;ba&quot;, &quot;bs&quot;, &quot; be&quot;, &quot;bfa&quot;, &quot;btech&quot;, &quot;llb&quot;,</span>
			&quot;bsc&quot;, &quot;ma&quot;, &quot;ms&quot;, &quot;msc&quot;, &quot;mfa&quot;, &quot;llm&quot;, &quot;mla&quot;, &quot;mha&quot;, &quot;mba&quot;, &quot;msc&quot;, &quot;meng&quot;, &quot;mph&quot;, &quot;mbi&quot;, &quot;jd&quot;, &quot;md&quot;, &quot;do&quot;,
			&quot;pharmd&quot;, &quot;dmin&quot;, &quot;phd&quot;, &quot;edd&quot;, &quot;dphil&quot;, &quot;dba&quot;, &quot;lld&quot;, &quot;engd&quot;, &quot;esq&quot;, &quot;rn&quot;, &quot;lpn&quot;, &quot;cna&quot;, &quot;bsn&quot;, &quot;msn&quot;,
			&quot;mss&quot;, &quot;msw&quot;, &quot;arpn&quot;, &quot;np&quot;, &quot;cnm&quot;, &quot;cns&quot;, &quot;crna&quot;, &quot;dns&quot;, &quot;dnp&quot;, &quot;dsw&quot;, &quot;mahs&quot;, &quot;maop&quot;, &quot;mc&quot;, &quot;mdiv&quot;, &quot;ddiv&quot;,
			&quot;psyd&quot;, &quot;psyad&quot;, &quot;scd&quot;, &quot;abcfp&quot;, &quot;abpn&quot;, &quot;abpp&quot;, &quot;acsw&quot;, &quot;amft&quot;, &quot;apcc&quot;, &quot;aprn&quot;, &quot;asw&quot;, &quot;atr&quot;, &quot;atrbc&quot;,
			&quot;bcdmt&quot;, &quot;bcd&quot;, &quot;catsm&quot;, &quot;cbt&quot;, &quot;ccc&quot;, &quot;cccr&quot;, &quot;cci&quot;, &quot;cct&quot;, &quot;cdt&quot;, &quot;cdv&quot;, &quot;cecr&quot;, &quot;cft&quot;, &quot;cit&quot;, &quot;cmvt&quot;,
			&quot;cpm&quot;, &quot;crt&quot;, &quot;csa&quot;, &quot;cscr&quot;, &quot;csm&quot;, &quot;cucr&quot;, &quot;cwt&quot;, &quot;cac&quot;, &quot;cacad&quot;, &quot;cadac&quot;, &quot;cadc&quot;, &quot;cags&quot;, &quot;camf&quot;, &quot;cap&quot;,
			&quot;cart&quot;, &quot;cas&quot;, &quot;casac&quot;, &quot;cbt&quot;, &quot;ccadc&quot;, &quot;ccdp&quot;, &quot;cch&quot;, &quot;ccht&quot;, &quot;ccmhc&quot;, &quot;ccpt&quot;, &quot;ccsw&quot;, &quot;ceap&quot;, &quot;ceds&quot;,
			&quot;cfle&quot;, &quot;cgp&quot;, &quot;cht&quot;, &quot;cicsw&quot;, &quot;cisw&quot;, &quot;cmat&quot;, &quot;cmft&quot;, &quot;cmsw&quot;, &quot;cp&quot;, &quot;cpastc&quot;, &quot;cpc&quot;, &quot;cplc&quot;, &quot;cradc&quot;,
			&quot;crc&quot;, &quot;csac&quot;, &quot;csat&quot;, &quot;csw&quot;, &quot;cswc&quot;, &quot;dapa&quot;, &quot;dcep&quot;, &quot;dcsw&quot;, &quot;dotsap&quot;, &quot;fnpbc&quot;, &quot;fnpc&quot;, &quot;fhl7&quot;, &quot;laadc&quot;, &quot;lac&quot;,
			&quot;ladac&quot;, &quot;ladc&quot;, &quot;lamft&quot;, &quot;lapc&quot;, &quot;lasac&quot;, &quot;lcadc&quot;, &quot;lcas&quot;, &quot;lcat&quot;, &quot;lcdc&quot;, &quot;lcdp&quot;, &quot;lcmft&quot;, &quot;lcmhc&quot;, &quot;lcp&quot;,
			&quot;lcpc&quot;, &quot;lcsw&quot;, &quot;lcsw-c&quot;, &quot;lgsw&quot;, &quot;licsw&quot;, &quot;limft&quot;, &quot;limhp&quot;, &quot;lisw&quot;, &quot;lisw-cp&quot;, &quot;llp&quot;, &quot;lmft&quot;, &quot;lmhc&quot;,
			&quot;lmhp&quot;, &quot;lmsw&quot;, &quot;lmswacp&quot;, &quot;lp&quot;, &quot;lpa&quot;, &quot;lpastc&quot;, &quot;lpc&quot;, &quot;lpcc&quot;, &quot;lpcmh&quot;, &quot;lpe&quot;, &quot;lpp&quot;, &quot;lsatp&quot;, &quot;lscsw&quot;,
			&quot;lsp&quot;, &quot;lsw&quot;, &quot;mac&quot;, &quot;mfcc&quot;, &quot;mft&quot;, &quot;mtbc&quot;, &quot;nbcch&quot;, &quot;nbcdch&quot;, &quot;ncc&quot;, &quot;ncpsya&quot;, &quot;ncsc&quot;, &quot;ncsp&quot;, &quot;pa&quot;,
			&quot;plmhp&quot;, &quot;plpc&quot;, &quot;pmhnp&quot;, &quot;pmhnpbc&quot;, &quot;pps&quot;, &quot;ras&quot;, &quot;rdmt&quot;, &quot;rdt&quot;, &quot;reat&quot;, &quot;rn&quot;, &quot;rpt&quot;, &quot;rpts&quot;, &quot;ryt&quot;, &quot;sap&quot;,
			&quot;sep&quot;, &quot;sw&quot;, &quot;tllp&quot;

	)));

<span class="fc" id="L58">	enum NamePart {</span>
<span class="fc" id="L59">		PREFIX, PREFIXANDSUFFIX, GIVEN, AFFIX, FAMILY, SUFFIX, NAME</span>
	}

	/**
	 * Construct a HumanNameParser
	 */
<span class="fc" id="L65">	public HumanNameParser() {</span>
		// Construct a default HumanNameParser
<span class="fc" id="L67">	}</span>

	@Override
	public Class&lt;HumanName&gt; type() {
<span class="nc" id="L71">		return HumanName.class;</span>
	}

	/**
	 * Parse a human name from a string. The parser recognizes common prefixes and
	 * suffixes and puts them in the prefix and suffix fields of the human name. It
	 * puts the first space separated string into the first given name, and any
	 * susbsequent strings except the last.
	 * 
	 * @param name The name to parse
	 * @return The parsed name in a HumanName object
	 */
	@Override
	public HumanName fromString(String name) {
<span class="fc" id="L85">		return computeFromString(name);</span>
	}
	
	/**
	 * Parse a human name from a string. The parser recognizes common prefixes and
	 * suffixes and puts them in the prefix and suffix fields of the human name. It
	 * puts the first space separated string into the first given name, and any
	 * susbsequent strings except the last.
	 * 
	 * @param name The name to parse
	 * @return The parsed name in a HumanName object
	 */
	public static HumanName computeFromString(String name) {
<span class="pc bpc" id="L98" title="1 of 2 branches missed.">		if (name == null) {</span>
<span class="nc" id="L99">			return null;</span>
		}
<span class="fc" id="L101">		HumanName hn = new HumanName();</span>
<span class="fc" id="L102">		hn.setText(name);</span>
<span class="fc" id="L103">		String[] parts = name.split(&quot;\\s&quot;);</span>
<span class="fc" id="L104">		StringBuilder familyName = new StringBuilder();</span>
<span class="fc bfc" id="L105" title="All 2 branches covered.">		for (String part : parts) {</span>
<span class="fc" id="L106">			updateNamePart(hn, familyName, part);</span>
		}
<span class="fc" id="L108">		List&lt;StringType&gt; given = hn.getGiven();</span>
<span class="pc bpc" id="L109" title="2 of 4 branches missed.">		if (familyName.isEmpty() &amp;&amp; !given.isEmpty()) {</span>
<span class="fc" id="L110">			String family = given.get(given.size() - 1).toString();</span>
<span class="fc" id="L111">			hn.setFamily(family);</span>
<span class="fc" id="L112">			given.remove(given.size() - 1);</span>
<span class="fc" id="L113">			hn.setGiven(null);</span>
<span class="fc bfc" id="L114" title="All 2 branches covered.">			for (StringType g : given) {</span>
<span class="fc" id="L115">				hn.addGiven(g.toString());</span>
<span class="fc" id="L116">			}</span>
<span class="pc bnc" id="L117" title="All 2 branches missed.">		} else if (!familyName.isEmpty()) {</span>
<span class="nc" id="L118">			familyName.setLength(familyName.length() - 1); // Remove terminal &quot; &quot;</span>
<span class="nc" id="L119">			hn.setFamily(familyName.toString());</span>
		}
<span class="fc bfc" id="L121" title="All 2 branches covered.">		if (hn.isEmpty()) {</span>
<span class="fc" id="L122">			return null;</span>
		}
<span class="fc" id="L124">		return hn;</span>
	}

	private static void updateNamePart(HumanName hn, StringBuilder familyName, String part) {
<span class="fc" id="L128">		NamePart classification = classifyNamePart(part);</span>
<span class="pc bpc" id="L129" title="4 of 6 branches missed.">		switch (classification) {</span>
		case PREFIXANDSUFFIX:
<span class="nc bnc" id="L131" title="All 4 branches missed.">			if (!hn.hasGiven() &amp;&amp; familyName.isEmpty()) {</span>
<span class="nc" id="L132">				hn.addPrefix(part);</span>
<span class="nc" id="L133">				return;</span>
			} 
<span class="nc bnc" id="L135" title="All 2 branches missed.">			if (familyName.isEmpty()) { </span>
				// could be a prefix or a suffix, but we haven't yet started
				// on suffixes and are beyond prefixes.  
				// Only thing that is both is &quot;sr&quot;.
				// We add it as a given name.
<span class="nc" id="L140">				hn.addGiven(part);</span>
<span class="nc" id="L141">				return;</span>
			}
			// Fall through to add suffix if we have some part of familyName
		case SUFFIX:
<span class="fc" id="L145">			hn.addSuffix(part);</span>
<span class="fc" id="L146">			return;</span>
		case PREFIX:
<span class="nc bnc" id="L148" title="All 4 branches missed.">			if (!hn.hasGiven() &amp;&amp; familyName.isEmpty()) {</span>
<span class="nc" id="L149">				hn.addPrefix(part);</span>
<span class="nc" id="L150">				return;</span>
			} 
<span class="nc" id="L152">			familyName.append(part).append(&quot; &quot;);</span>
<span class="nc" id="L153">			return;</span>
		case AFFIX:
<span class="nc bnc" id="L155" title="All 2 branches missed.">			if (!hn.hasGiven()) {</span>
<span class="nc" id="L156">				hn.addGiven(part);</span>
<span class="nc" id="L157">				return;</span>
			} 
<span class="nc" id="L159">			familyName.append(part).append(&quot; &quot;);</span>
<span class="nc" id="L160">			return;</span>
		case NAME:
<span class="pc bpc" id="L162" title="1 of 2 branches missed.">			if (familyName.isEmpty()) {</span>
<span class="fc" id="L163">				hn.addGiven(part);</span>
<span class="fc" id="L164">				return;</span>
			} 
<span class="nc" id="L166">			familyName.append(part).append(&quot; &quot;);</span>
<span class="nc" id="L167">			return;</span>
		default:
<span class="nc" id="L169">			return;</span>
		}
	}

	private static NamePart classifyNamePart(String part) {
<span class="pc bpc" id="L174" title="1 of 2 branches missed.">		if (isPrefix(part)) {</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">			return isSuffix(part) ? NamePart.PREFIXANDSUFFIX : NamePart.PREFIX;</span>
		}
<span class="pc bpc" id="L177" title="1 of 2 branches missed.">		if (isAffix(part)) {</span>
<span class="nc" id="L178">			return NamePart.AFFIX;</span>
		}
<span class="pc bpc" id="L180" title="1 of 4 branches missed.">		if (isSuffix(part) || isDegree(part)) {</span>
<span class="fc" id="L181">			return NamePart.SUFFIX;</span>
		}
<span class="fc" id="L183">		return NamePart.NAME;</span>
	}

	@Override
	public HumanName convert(Type t) {
<span class="fc" id="L188">		t = DatatypeConverter.adjustIfVaries(t);</span>
<span class="pc bpc" id="L189" title="1 of 2 branches missed.">		if (t instanceof Primitive pt) {</span>
<span class="nc bnc" id="L190" title="All 4 branches missed.">			if (t instanceof Primitive p &amp;&amp; DatatypeConverter.isDeleted(p)) {</span>
<span class="nc" id="L191">				return DatatypeConverter.markDeleted(new HumanName());</span>
			}

<span class="nc" id="L194">			return fromString(pt.getValue());</span>
		}

<span class="pc bpc" id="L197" title="1 of 2 branches missed.">		if (t instanceof Composite comp) {</span>
<span class="fc" id="L198">			Type[] types = comp.getComponents();</span>
<span class="pc bpc" id="L199" title="2 of 4 branches missed.">			switch (t.getName()) {</span>
			case &quot;CNN&quot;:
<span class="nc" id="L201">				return HumanNameParser.parse(types, 1, -1);</span>
			case &quot;XCN&quot;:
<span class="fc" id="L203">				HumanName hn = HumanNameParser.parse(types, 1, 9);</span>
<span class="pc bpc" id="L204" title="3 of 6 branches missed.">				if (hn != null &amp;&amp; types.length &gt; 20 &amp;&amp; types[20] != null) {</span>
<span class="fc" id="L205">					String suffix = ParserUtils.toString(types[20]);</span>
<span class="fc" id="L206">					hn.addSuffix(suffix);</span>
				}
<span class="fc" id="L208">				return hn;</span>
			case &quot;XPN&quot;:
<span class="fc" id="L210">				return HumanNameParser.parse(types, 0, 6);</span>
			default:
				break;
			}
		}
<span class="nc" id="L215">		return null;</span>
	}

	@Override
	public Type convert(HumanName name) {
<span class="nc" id="L220">		return null;</span>
	}

	static HumanName parse(Type[] types, int offset, int nameTypeLoc) {
<span class="fc" id="L224">		HumanName hn = new HumanName();</span>
<span class="fc bfc" id="L225" title="All 2 branches covered.">		for (int i = 0; i &lt; 6; i++) {</span>
<span class="fc" id="L226">			String part = ParserUtils.toString(types[i + offset]);</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">			if (StringUtils.isBlank(part)) {</span>
<span class="fc" id="L228">				continue;</span>
			}
<span class="pc bpc" id="L230" title="4 of 7 branches missed.">			switch (i) {</span>
			case 0: // Family Name (as ST in HL7 2.3)
<span class="fc" id="L232">				hn.setFamily(part);</span>
<span class="fc" id="L233">				break;</span>
			case 1: // Given Name
<span class="fc" id="L235">				hn.addGiven(part);</span>
<span class="fc" id="L236">				break;</span>
			case 2: // Second and Further Given Name or Initials
					// Thereof
<span class="fc" id="L239">				hn.addGiven(part);</span>
<span class="fc" id="L240">				break;</span>
			case 3: // Suffix
<span class="nc" id="L242">				hn.addSuffix(part);</span>
<span class="nc" id="L243">				break;</span>
			case 4: // Prefix
<span class="nc" id="L245">				hn.addPrefix(part);</span>
<span class="nc" id="L246">				break;</span>
			case 5: // Degree
<span class="nc" id="L248">				hn.addSuffix(part);</span>
<span class="nc" id="L249">				break;</span>
			default:
				break;
			}
		}
<span class="fc" id="L254">		Type type = DatatypeConverter.adjustIfVaries(types, nameTypeLoc);</span>

<span class="pc bpc" id="L256" title="1 of 2 branches missed.">		if (type instanceof Primitive pt) {</span>
<span class="fc" id="L257">			String nameType = pt.getValue();</span>
<span class="fc" id="L258">			hn.setUse(toNameUse(nameType));</span>
		}
<span class="fc bfc" id="L260" title="All 2 branches covered.">		if (hn.isEmpty()) {</span>
<span class="fc" id="L261">			return null;</span>
		}
<span class="fc" id="L263">		return hn;</span>
	}

	private static NameUse toNameUse(String nameType) {
<span class="fc bfc" id="L267" title="All 2 branches covered.">		if (nameType == null) {</span>
<span class="fc" id="L268">			return null;</span>
		}
<span class="pc bpc" id="L270" title="6 of 9 branches missed.">		switch (StringUtils.upperCase(nameType)) {</span>
		case &quot;A&quot;: // Assigned
<span class="nc" id="L272">			return NameUse.USUAL;</span>
		case &quot;D&quot;: // Customary Name
<span class="nc" id="L274">			return NameUse.USUAL;</span>
		case &quot;L&quot;: // Official Registry Name
<span class="fc" id="L276">			return NameUse.OFFICIAL;</span>
		case &quot;M&quot;: // Maiden Name
<span class="fc" id="L278">			return NameUse.MAIDEN;</span>
		case &quot;N&quot;: // Nickname
<span class="nc" id="L280">			return NameUse.NICKNAME;</span>
		case &quot;NOUSE&quot;: // No Longer To Be Used
<span class="nc" id="L282">			return NameUse.OLD;</span>
		case &quot;R&quot;: // Registered Name
<span class="nc" id="L284">			return NameUse.OFFICIAL;</span>
		case &quot;TEMP&quot;: // Temporary Name
<span class="nc" id="L286">			return NameUse.TEMP;</span>
		case &quot;B&quot;, // Birth name
				&quot;BAD&quot;, // Bad Name
				&quot;C&quot;, // Adopted Name
				&quot;I&quot;, // Licensing Name
				&quot;K&quot;, // Business name
				&quot;MSK&quot;, // Masked
				&quot;NAV&quot;, // Temporarily Unavailable
				&quot;NB&quot;, // Newborn Name
				&quot;P&quot;, // Name of Partner/Spouse
				&quot;REL&quot;, // Religious
				&quot;S&quot;, // Pseudonym
				&quot;T&quot;, // Indigenous/Tribal
				&quot;U&quot;: // Unknown
		default:
<span class="fc" id="L301">			return null;</span>
		}
	}

	/**
	 * Sees if the string is an affix
	 * @param part	The string to check
	 * @return	True if it is an affix to the name.
	 */
	public static boolean isAffix(String part) {
<span class="fc" id="L311">		return AFFIXES.contains(StringUtils.lowerCase(part));</span>
	}

	/**
	 * Sees if the string is an prefix
	 * @param part	The string to check
	 * @return	True if it is an prefix to the name.
	 */
	public static boolean isPrefix(String part) {
<span class="fc" id="L320">		return PREFIXES.contains(StringUtils.replace(StringUtils.lowerCase(part), &quot;.&quot;, &quot;&quot;));</span>
	}

	/**
	 * Sees if the string is an suffix
	 * @param part	The string to check
	 * @return	True if it is an suffix to the name.
	 */
	public static boolean isSuffix(String part) {
<span class="fc" id="L329">		return SUFFIXES.contains(StringUtils.replace(StringUtils.lowerCase(part), &quot;.&quot;, &quot;&quot;));</span>
	}

	/**
	 * Sees if the string is a degree (e.g., MD)
	 * @param part	The string to check
	 * @return	True if it is a degree following the name
	 */
	public static boolean isDegree(String part) {
<span class="fc" id="L338">		return DEGREES.contains(StringUtils.replace(StringUtils.lowerCase(part), &quot;.&quot;, &quot;&quot;));</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>