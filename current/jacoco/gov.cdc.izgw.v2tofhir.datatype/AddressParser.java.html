<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AddressParser.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">HL7 Version 2 to FHIR Conversion</a> &gt; <a href="index.source.html" class="el_package">gov.cdc.izgw.v2tofhir.datatype</a> &gt; <span class="el_source">AddressParser.java</span></div><h1>AddressParser.java</h1><pre class="source lang-java linenums">package gov.cdc.izgw.v2tofhir.datatype;

import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.regex.Pattern;

import org.apache.commons.lang3.StringUtils;
import org.hl7.fhir.r4.model.Address;
import org.hl7.fhir.r4.model.Address.AddressUse;
import org.hl7.fhir.r4.model.StringType;

import ca.uhn.hl7v2.model.Composite;
import ca.uhn.hl7v2.model.Primitive;
import ca.uhn.hl7v2.model.Type;
import gov.cdc.izgw.v2tofhir.converter.DatatypeConverter;
import gov.cdc.izgw.v2tofhir.utils.ParserUtils;
import lombok.extern.slf4j.Slf4j;

/**
 * AddressParser is a parser for addresses.
 * 
 * @author Audacious Inquiry
 */
<span class="fc" id="L25">@Slf4j</span>
public class AddressParser implements DatatypeParser&lt;Address&gt; {
	static {
<span class="fc" id="L28">		log.debug(&quot;{} loaded&quot;, AddressParser.class.getName());</span>
	}
<span class="fc" id="L30">	private static final Pattern caPostalCode1 = Pattern</span>
<span class="fc" id="L31">			.compile(&quot;^[a-zA-Z]\\d[a-zA-Z]$&quot;);</span>

<span class="fc" id="L33">	private static final Pattern caPostalCode2 = Pattern</span>
<span class="fc" id="L34">			.compile(&quot;^\\d[a-zA-Z]\\d$&quot;);</span>

<span class="fc" id="L36">	private static final Pattern countryPattern = ParserUtils.toPattern(&quot;US&quot;,</span>
			&quot;U.S.&quot;, &quot;U.S.A.&quot;, &quot;USA&quot;, &quot;United States&quot;,
			&quot;United States of America&quot;, &quot;CN&quot;, &quot;Canada&quot;, &quot;MX&quot;, &quot;Mexico&quot;, &quot;BZ&quot;,
			&quot;BELIZE&quot;, &quot;CR&quot;, &quot;COSTA RICA&quot;, &quot;CZ&quot;, &quot;CANAL ZONE&quot;, &quot;SV&quot;,
			&quot;EL SALVADOR&quot;, &quot;GT&quot;, &quot;GUATEMALA&quot;, &quot;HN&quot;, &quot;HONDURAS&quot;, &quot;NI&quot;,
			&quot;NICARAGUA&quot;, &quot;PA&quot;, &quot;PANAMA&quot;);

<span class="fc" id="L43">	private static final Pattern postalCodePattern = Pattern.compile(</span>
			&quot;^\\d{5}$|^\\d{5}-\\d{4}$|^[a-zA-Z]\\d[a-zA-Z]-\\d[a-zA-Z]\\d$&quot;);
<span class="fc" id="L45">	private static final String[] states = {</span>
			&quot;AL&quot;, &quot;Alabama&quot;, &quot;AK&quot;, &quot;Alaska&quot;, &quot;AZ&quot;, &quot;Arizona&quot;, &quot;AR&quot;, &quot;Arkansas&quot;, &quot;AS&quot;,
			&quot;American Samoa&quot;, &quot;CA&quot;, &quot;California&quot;, &quot;CO&quot;, &quot;Colorado&quot;, &quot;CT&quot;,
			&quot;Connecticut&quot;, &quot;DE&quot;, &quot;Delaware&quot;, &quot;DC&quot;, &quot;District of Columbia&quot;, &quot;FL&quot;,
			&quot;Florida&quot;, &quot;GA&quot;, &quot;Georgia&quot;, &quot;GU&quot;, &quot;Guam&quot;, &quot;HI&quot;, &quot;Hawaii&quot;, &quot;ID&quot;,
			&quot;Idaho&quot;, &quot;IL&quot;, &quot;Illinois&quot;, &quot;IN&quot;, &quot;Indiana&quot;, &quot;IA&quot;, &quot;Iowa&quot;, &quot;KS&quot;,
			&quot;Kansas&quot;, &quot;KY&quot;, &quot;Kentucky&quot;, &quot;LA&quot;, &quot;Louisiana&quot;, &quot;ME&quot;, &quot;Maine&quot;, &quot;MD&quot;,
			&quot;Maryland&quot;, &quot;MA&quot;, &quot;Massachusetts&quot;, &quot;MI&quot;, &quot;Michigan&quot;, &quot;MN&quot;,
			&quot;Minnesota&quot;, &quot;MS&quot;, &quot;Mississippi&quot;, &quot;MO&quot;, &quot;Missouri&quot;, &quot;MT&quot;, &quot;Montana&quot;,
			&quot;NE&quot;, &quot;Nebraska&quot;, &quot;NV&quot;, &quot;Nevada&quot;, &quot;NH&quot;, &quot;New Hampshire&quot;, &quot;NJ&quot;,
			&quot;New Jersey&quot;, &quot;NM&quot;, &quot;New Mexico&quot;, &quot;NY&quot;, &quot;New York&quot;, &quot;NC&quot;,
			&quot;North Carolina&quot;, &quot;ND&quot;, &quot;North Dakota&quot;, &quot;MP&quot;,
			&quot;Northern Mariana Islands&quot;, &quot;OH&quot;, &quot;Ohio&quot;, &quot;OK&quot;, &quot;Oklahoma&quot;, &quot;OR&quot;,
			&quot;Oregon&quot;, &quot;PA&quot;, &quot;Pennsylvania&quot;, &quot;PR&quot;, &quot;Puerto Rico&quot;, &quot;RI&quot;,
			&quot;Rhode Island&quot;, &quot;SC&quot;, &quot;South Carolina&quot;, &quot;SD&quot;, &quot;South Dakota&quot;, &quot;TN&quot;,
			&quot;Tennessee&quot;, &quot;TX&quot;, &quot;Texas&quot;, &quot;TT&quot;, &quot;Trust Territories&quot;, &quot;UT&quot;, &quot;Utah&quot;,
			&quot;VT&quot;, &quot;Vermont&quot;, &quot;VA&quot;, &quot;Virginia&quot;, &quot;VI&quot;, &quot;Virgin Islands&quot;, &quot;WA&quot;,
			&quot;Washington&quot;, &quot;WV&quot;, &quot;West Virginia&quot;, &quot;WI&quot;, &quot;Wisconsin&quot;, &quot;WY&quot;,
			&quot;Wyoming&quot;, &quot;Newfoundland and Labrador&quot;, &quot;Newfoundland&quot;, &quot;Labrador&quot;,
			&quot;NL&quot;, &quot;Prince Edward Island&quot;, &quot;PE&quot;, &quot;Nova Scotia&quot;, &quot;NS&quot;,
			&quot;New Brunswick&quot;, &quot;NB&quot;, &quot;Quebec&quot;, &quot;QC&quot;, &quot;Ontario&quot;, &quot;ON&quot;, &quot;Manitoba&quot;,
			&quot;MB&quot;, &quot;Saskatchewan&quot;, &quot;SK&quot;, &quot;Alberta&quot;, &quot;AB&quot;, &quot;British Columbia&quot;,
			&quot;BC&quot;, &quot;Yukon&quot;, &quot;YT&quot;, &quot;Northwest Territories&quot;, &quot;NT&quot;, &quot;Nunavut&quot;, &quot;NU&quot;,
			&quot;AG&quot;, &quot;AGUASCALIENTES&quot;, &quot;BN&quot;, &quot;BAJA CALIFORNIA NORTE&quot;, &quot;BS&quot;,
			&quot;BAJA CALIFORNIA SUR&quot;, &quot;CH&quot;, &quot;COAHUILA&quot;, &quot;CI&quot;, &quot;CHIHUAHUA&quot;, &quot;CL&quot;,
			&quot;COLIMA&quot;, &quot;CP&quot;, &quot;CAMPECHE&quot;, &quot;CS&quot;, &quot;CHIAPAS&quot;, &quot;DF&quot;,
			&quot;DISTRICTO FEDERAL&quot;, &quot;DG&quot;, &quot;DURANGO&quot;, &quot;GE&quot;, &quot;GUERRERO&quot;, &quot;GJ&quot;,
			&quot;GUANAJUATO&quot;, &quot;HD&quot;, &quot;HIDALGO&quot;, &quot;JA&quot;, &quot;JALISCO&quot;, &quot;MC&quot;, &quot;MICHOACAN&quot;,
			&quot;MR&quot;, &quot;MORELOS&quot;, &quot;MX&quot;, &quot;MEXICO&quot;, &quot;NA&quot;, &quot;NAYARIT&quot;, &quot;NL&quot;,
			&quot;NUEVO LEON&quot;, &quot;OA&quot;, &quot;OAXACA&quot;, &quot;PU&quot;, &quot;PUEBLA&quot;, &quot;QE&quot;, &quot;QUERETARO&quot;,
			&quot;QI&quot;, &quot;QUINTANA ROO&quot;, &quot;SI&quot;, &quot;SINALOA&quot;, &quot;SL&quot;, &quot;SAN LUIS POTOSI&quot;,
			&quot;SO&quot;, &quot;SONORA&quot;, &quot;TA&quot;, &quot;TAMAULIPAS&quot;, &quot;TB&quot;, &quot;TABASCO&quot;, &quot;TL&quot;,
			&quot;TLAXCALA&quot;, &quot;VC&quot;, &quot;VERACRUZ&quot;, &quot;YU&quot;, &quot;YUCATAN&quot;, &quot;ZA&quot;, &quot;ZACATECA&quot;
	};
<span class="fc" id="L79">	private static final Pattern statePattern = ParserUtils.toPattern(states);</span>
<span class="fc" id="L80">	private static final Map&lt;String, String[]&gt; STATE_MAP = new LinkedHashMap&lt;&gt;();</span>
	static {
<span class="fc bfc" id="L82" title="All 2 branches covered.">		for (int i = 0; i &lt; states.length; i += 2) {</span>
<span class="fc" id="L83">			String[] stateAndAbbreviation = { states[i], states[i + 1] };</span>
<span class="fc" id="L84">			STATE_MAP.put(stateAndAbbreviation[0], stateAndAbbreviation);</span>
<span class="fc" id="L85">			STATE_MAP.put(stateAndAbbreviation[1].toUpperCase(), stateAndAbbreviation);</span>
		}
	}

	// See https://pe.usps.com/text/pub28/28apc_002.htm
<span class="fc" id="L90">	private static final Pattern streetPattern = ParserUtils.toPattern(&quot;ALLEE&quot;,</span>
			&quot;ALLEY&quot;, &quot;ALLY&quot;, &quot;ALY&quot;, &quot;ANEX&quot;, &quot;ANNEX&quot;, &quot;ANNX&quot;, &quot;ANX&quot;, &quot;ARC&quot;,
			&quot;ARCADE&quot;, &quot;AV&quot;, &quot;AVE&quot;, &quot;AVEN&quot;, &quot;AVENU&quot;, &quot;AVENUE&quot;, &quot;AVN&quot;, &quot;AVNUE&quot;,
			&quot;BAYOO&quot;, &quot;BAYOU&quot;, &quot;BCH&quot;, &quot;BEACH&quot;, &quot;BEND&quot;, &quot;BG&quot;, &quot;BGS&quot;, &quot;BLF&quot;,
			&quot;BLFS&quot;, &quot;BLUF&quot;, &quot;BLUFF&quot;, &quot;BLUFFS&quot;, &quot;BLVD&quot;, &quot;BND&quot;, &quot;BOT&quot;, &quot;BOTTM&quot;,
			&quot;BOTTOM&quot;, &quot;BOUL&quot;, &quot;BOULEVARD&quot;, &quot;BOULV&quot;, &quot;BR&quot;, &quot;BRANCH&quot;, &quot;BRDGE&quot;,
			&quot;BRG&quot;, &quot;BRIDGE&quot;, &quot;BRK&quot;, &quot;BRKS&quot;, &quot;BRNCH&quot;, &quot;BROOK&quot;, &quot;BROOKS&quot;, &quot;BTM&quot;,
			&quot;BURG&quot;, &quot;BURGS&quot;, &quot;BYP&quot;, &quot;BYPA&quot;, &quot;BYPAS&quot;, &quot;BYPASS&quot;, &quot;BYPS&quot;, &quot;BYU&quot;,
			&quot;CAMP&quot;, &quot;CANYN&quot;, &quot;CANYON&quot;, &quot;CAPE&quot;, &quot;CAUSEWAY&quot;, &quot;CAUSWA&quot;, &quot;CEN&quot;,
			&quot;CENT&quot;, &quot;CENTER&quot;, &quot;CENTERS&quot;, &quot;CENTR&quot;, &quot;CENTRE&quot;, &quot;CIR&quot;, &quot;CIRC&quot;,
			&quot;CIRCL&quot;, &quot;CIRCLE&quot;, &quot;CIRCLES&quot;, &quot;CIRS&quot;, &quot;CLB&quot;, &quot;CLF&quot;, &quot;CLFS&quot;, &quot;CLIFF&quot;,
			&quot;CLIFFS&quot;, &quot;CLUB&quot;, &quot;CMN&quot;, &quot;CMNS&quot;, &quot;CMP&quot;, &quot;CNTER&quot;, &quot;CNTR&quot;, &quot;CNYN&quot;,
			&quot;COMMON&quot;, &quot;COMMONS&quot;, &quot;COR&quot;, &quot;CORNER&quot;, &quot;CORNERS&quot;, &quot;CORS&quot;, &quot;COURSE&quot;,
			&quot;COURT&quot;, &quot;COURTS&quot;, &quot;COVE&quot;, &quot;COVES&quot;, &quot;CP&quot;, &quot;CPE&quot;, &quot;CRCL&quot;, &quot;CRCLE&quot;,
			&quot;CREEK&quot;, &quot;CRES&quot;, &quot;CRESCENT&quot;, &quot;CREST&quot;, &quot;CRK&quot;, &quot;CROSSING&quot;,
			&quot;CROSSROAD&quot;, &quot;CROSSROADS&quot;, &quot;CRSE&quot;, &quot;CRSENT&quot;, &quot;CRSNT&quot;, &quot;CRSSNG&quot;,
			&quot;CRST&quot;, &quot;CSWY&quot;, &quot;CT&quot;, &quot;CTR&quot;, &quot;CTRS&quot;, &quot;CTS&quot;, &quot;CURV&quot;, &quot;CURVE&quot;, &quot;CV&quot;,
			&quot;CVS&quot;, &quot;CYN&quot;, &quot;DALE&quot;, &quot;DAM&quot;, &quot;DIV&quot;, &quot;DIVIDE&quot;, &quot;DL&quot;, &quot;DM&quot;, &quot;DR&quot;,
			&quot;DRIV&quot;, &quot;DRIVE&quot;, &quot;DRIVES&quot;, &quot;DRS&quot;, &quot;DRV&quot;, &quot;DV&quot;, &quot;DVD&quot;, &quot;EST&quot;,
			&quot;ESTATE&quot;, &quot;ESTATES&quot;, &quot;ESTS&quot;, &quot;EXP&quot;, &quot;EXPR&quot;, &quot;EXPRESS&quot;, &quot;EXPRESSWAY&quot;,
			&quot;EXPW&quot;, &quot;EXPY&quot;, &quot;EXT&quot;, &quot;EXTENSION&quot;, &quot;EXTENSIONS&quot;, &quot;EXTN&quot;, &quot;EXTNSN&quot;,
			&quot;EXTS&quot;, &quot;FALL&quot;, &quot;FALLS&quot;, &quot;FERRY&quot;, &quot;FIELD&quot;, &quot;FIELDS&quot;, &quot;FLAT&quot;,
			&quot;FLATS&quot;, &quot;FLD&quot;, &quot;FLDS&quot;, &quot;FLS&quot;, &quot;FLT&quot;, &quot;FLTS&quot;, &quot;FORD&quot;, &quot;FORDS&quot;,
			&quot;FOREST&quot;, &quot;FORESTS&quot;, &quot;FORG&quot;, &quot;FORGE&quot;, &quot;FORGES&quot;, &quot;FORK&quot;, &quot;FORKS&quot;,
			&quot;FORT&quot;, &quot;FRD&quot;, &quot;FRDS&quot;, &quot;FREEWAY&quot;, &quot;FREEWY&quot;, &quot;FRG&quot;, &quot;FRGS&quot;, &quot;FRK&quot;,
			&quot;FRKS&quot;, &quot;FRRY&quot;, &quot;FRST&quot;, &quot;FRT&quot;, &quot;FRWAY&quot;, &quot;FRWY&quot;, &quot;FRY&quot;, &quot;FT&quot;, &quot;FWY&quot;,
			&quot;GARDEN&quot;, &quot;GARDENS&quot;, &quot;GARDN&quot;, &quot;GATEWAY&quot;, &quot;GATEWY&quot;, &quot;GATWAY&quot;, &quot;GDN&quot;,
			&quot;GDNS&quot;, &quot;GLEN&quot;, &quot;GLENS&quot;, &quot;GLN&quot;, &quot;GLNS&quot;, &quot;GRDEN&quot;, &quot;GRDN&quot;, &quot;GRDNS&quot;,
			&quot;GREEN&quot;, &quot;GREENS&quot;, &quot;GRN&quot;, &quot;GRNS&quot;, &quot;GROV&quot;, &quot;GROVE&quot;, &quot;GROVES&quot;, &quot;GRV&quot;,
			&quot;GRVS&quot;, &quot;GTWAY&quot;, &quot;GTWY&quot;, &quot;HARB&quot;, &quot;HARBOR&quot;, &quot;HARBORS&quot;, &quot;HARBR&quot;,
			&quot;HAVEN&quot;, &quot;HBR&quot;, &quot;HBRS&quot;, &quot;HEIGHTS&quot;, &quot;HIGHWAY&quot;, &quot;HIGHWY&quot;, &quot;HILL&quot;,
			&quot;HILLS&quot;, &quot;HIWAY&quot;, &quot;HIWY&quot;, &quot;HL&quot;, &quot;HLLW&quot;, &quot;HLS&quot;, &quot;HOLLOW&quot;, &quot;HOLLOWS&quot;,
			&quot;HOLW&quot;, &quot;HOLWS&quot;, &quot;HRBOR&quot;, &quot;HT&quot;, &quot;HTS&quot;, &quot;HVN&quot;, &quot;HWAY&quot;, &quot;HWY&quot;,
			&quot;INLET&quot;, &quot;INLT&quot;, &quot;IS&quot;, &quot;ISLAND&quot;, &quot;ISLANDS&quot;, &quot;ISLE&quot;, &quot;ISLES&quot;,
			&quot;ISLND&quot;, &quot;ISLNDS&quot;, &quot;ISS&quot;, &quot;JCT&quot;, &quot;JCTION&quot;, &quot;JCTN&quot;, &quot;JCTNS&quot;, &quot;JCTS&quot;,
			&quot;JUNCTION&quot;, &quot;JUNCTIONS&quot;, &quot;JUNCTN&quot;, &quot;JUNCTON&quot;, &quot;KEY&quot;, &quot;KEYS&quot;, &quot;KNL&quot;,
			&quot;KNLS&quot;, &quot;KNOL&quot;, &quot;KNOLL&quot;, &quot;KNOLLS&quot;, &quot;KY&quot;, &quot;KYS&quot;, &quot;LAKE&quot;, &quot;LAKES&quot;,
			&quot;LAND&quot;, &quot;LANDING&quot;, &quot;LANE&quot;, &quot;LCK&quot;, &quot;LCKS&quot;, &quot;LDG&quot;, &quot;LDGE&quot;, &quot;LF&quot;,
			&quot;LGT&quot;, &quot;LGTS&quot;, &quot;LIGHT&quot;, &quot;LIGHTS&quot;, &quot;LK&quot;, &quot;LKS&quot;, &quot;LN&quot;, &quot;LNDG&quot;,
			&quot;LNDNG&quot;, &quot;LOAF&quot;, &quot;LOCK&quot;, &quot;LOCKS&quot;, &quot;LODG&quot;, &quot;LODGE&quot;, &quot;LOOP&quot;, &quot;LOOPS&quot;,
			&quot;MALL&quot;, &quot;MANOR&quot;, &quot;MANORS&quot;, &quot;MDW&quot;, &quot;MDWS&quot;, &quot;MEADOW&quot;, &quot;MEADOWS&quot;,
			&quot;MEDOWS&quot;, &quot;MEWS&quot;, &quot;MILL&quot;, &quot;MILLS&quot;, &quot;MISSION&quot;, &quot;MISSN&quot;, &quot;ML&quot;, &quot;MLS&quot;,
			&quot;MNR&quot;, &quot;MNRS&quot;, &quot;MNT&quot;, &quot;MNTAIN&quot;, &quot;MNTN&quot;, &quot;MNTNS&quot;, &quot;MOTORWAY&quot;,
			&quot;MOUNT&quot;, &quot;MOUNTAIN&quot;, &quot;MOUNTAINS&quot;, &quot;MOUNTIN&quot;, &quot;MSN&quot;, &quot;MSSN&quot;, &quot;MT&quot;,
			&quot;MTIN&quot;, &quot;MTN&quot;, &quot;MTNS&quot;, &quot;MTWY&quot;, &quot;NCK&quot;, &quot;NECK&quot;, &quot;OPAS&quot;, &quot;ORCH&quot;,
			&quot;ORCHARD&quot;, &quot;ORCHRD&quot;, &quot;OVAL&quot;, &quot;OVERPASS&quot;, &quot;OVL&quot;, &quot;PARK&quot;, &quot;PARKS&quot;,
			&quot;PARKWAY&quot;, &quot;PARKWAYS&quot;, &quot;PARKWY&quot;, &quot;PASS&quot;, &quot;PASSAGE&quot;, &quot;PATH&quot;, &quot;PATHS&quot;,
			&quot;PIKE&quot;, &quot;PIKES&quot;, &quot;PINE&quot;, &quot;PINES&quot;, &quot;PKWAY&quot;, &quot;PKWY&quot;, &quot;PKWYS&quot;, &quot;PKY&quot;,
			&quot;PL&quot;, &quot;PLACE&quot;, &quot;PLAIN&quot;, &quot;PLAINS&quot;, &quot;PLAZA&quot;, &quot;PLN&quot;, &quot;PLNS&quot;, &quot;PLZ&quot;,
			&quot;PLZA&quot;, &quot;PNE&quot;, &quot;PNES&quot;, &quot;POINT&quot;, &quot;POINTS&quot;, &quot;PORT&quot;, &quot;PORTS&quot;, &quot;PR&quot;,
			&quot;PRAIRIE&quot;, &quot;PRK&quot;, &quot;PRR&quot;, &quot;PRT&quot;, &quot;PRTS&quot;, &quot;PSGE&quot;, &quot;PT&quot;, &quot;PTS&quot;, &quot;RAD&quot;,
			&quot;RADIAL&quot;, &quot;RADIEL&quot;, &quot;RADL&quot;, &quot;RAMP&quot;, &quot;RANCH&quot;, &quot;RANCHES&quot;, &quot;RAPID&quot;,
			&quot;RAPIDS&quot;, &quot;RD&quot;, &quot;RDG&quot;, &quot;RDGE&quot;, &quot;RDGS&quot;, &quot;RDS&quot;, &quot;REST&quot;, &quot;RIDGE&quot;,
			&quot;RIDGES&quot;, &quot;RIV&quot;, &quot;RIVER&quot;, &quot;RIVR&quot;, &quot;RNCH&quot;, &quot;RNCHS&quot;, &quot;ROAD&quot;, &quot;ROADS&quot;,
			&quot;ROUTE&quot;, &quot;ROW&quot;, &quot;RPD&quot;, &quot;RPDS&quot;, &quot;RST&quot;, &quot;RTE&quot;, &quot;RUE&quot;, &quot;RUN&quot;, &quot;RVR&quot;,
			&quot;SHL&quot;, &quot;SHLS&quot;, &quot;SHOAL&quot;, &quot;SHOALS&quot;, &quot;SHOAR&quot;, &quot;SHOARS&quot;, &quot;SHORE&quot;,
			&quot;SHORES&quot;, &quot;SHR&quot;, &quot;SHRS&quot;, &quot;SKWY&quot;, &quot;SKYWAY&quot;, &quot;SMT&quot;, &quot;SPG&quot;, &quot;SPGS&quot;,
			&quot;SPNG&quot;, &quot;SPNGS&quot;, &quot;SPRING&quot;, &quot;SPRINGS&quot;, &quot;SPRNG&quot;, &quot;SPRNGS&quot;, &quot;SPUR&quot;,
			&quot;SPURS&quot;, &quot;SQ&quot;, &quot;SQR&quot;, &quot;SQRE&quot;, &quot;SQRS&quot;, &quot;SQS&quot;, &quot;SQU&quot;, &quot;SQUARE&quot;,
			&quot;SQUARES&quot;, &quot;ST&quot;, &quot;STA&quot;, &quot;STATION&quot;, &quot;STATN&quot;, &quot;STN&quot;, &quot;STR&quot;, &quot;STRA&quot;,
			&quot;STRAV&quot;, &quot;STRAVEN&quot;, &quot;STRAVENUE&quot;, &quot;STRAVN&quot;, &quot;STREAM&quot;, &quot;STREET&quot;,
			&quot;STREETS&quot;, &quot;STREME&quot;, &quot;STRM&quot;, &quot;STRT&quot;, &quot;STRVN&quot;, &quot;STRVNUE&quot;, &quot;STS&quot;,
			&quot;SUMIT&quot;, &quot;SUMITT&quot;, &quot;SUMMIT&quot;, &quot;TER&quot;, &quot;TERR&quot;, &quot;TERRACE&quot;, &quot;THROUGHWAY&quot;,
			&quot;TPKE&quot;, &quot;TRACE&quot;, &quot;TRACES&quot;, &quot;TRACK&quot;, &quot;TRACKS&quot;, &quot;TRAFFICWAY&quot;, &quot;TRAIL&quot;,
			&quot;TRAILER&quot;, &quot;TRAILS&quot;, &quot;TRAK&quot;, &quot;TRCE&quot;, &quot;TRFY&quot;, &quot;TRK&quot;, &quot;TRKS&quot;, &quot;TRL&quot;,
			&quot;TRLR&quot;, &quot;TRLRS&quot;, &quot;TRLS&quot;, &quot;TRNPK&quot;, &quot;TRWY&quot;, &quot;TUNEL&quot;, &quot;TUNL&quot;, &quot;TUNLS&quot;,
			&quot;TUNNEL&quot;, &quot;TUNNELS&quot;, &quot;TUNNL&quot;, &quot;TURNPIKE&quot;, &quot;TURNPK&quot;, &quot;UN&quot;,
			&quot;UNDERPASS&quot;, &quot;UNION&quot;, &quot;UNIONS&quot;, &quot;UNS&quot;, &quot;UPAS&quot;, &quot;VALLEY&quot;, &quot;VALLEYS&quot;,
			&quot;VALLY&quot;, &quot;VDCT&quot;, &quot;VIA&quot;, &quot;VIADCT&quot;, &quot;VIADUCT&quot;, &quot;VIEW&quot;, &quot;VIEWS&quot;,
			&quot;VILL&quot;, &quot;VILLAG&quot;, &quot;VILLAGE&quot;, &quot;VILLAGES&quot;, &quot;VILLE&quot;, &quot;VILLG&quot;,
			&quot;VILLIAGE&quot;, &quot;VIS&quot;, &quot;VIST&quot;, &quot;VISTA&quot;, &quot;VL&quot;, &quot;VLG&quot;, &quot;VLGS&quot;, &quot;VLLY&quot;,
			&quot;VLY&quot;, &quot;VLYS&quot;, &quot;VST&quot;, &quot;VSTA&quot;, &quot;VW&quot;, &quot;VWS&quot;, &quot;WALK&quot;, &quot;WALKS&quot;, &quot;WALL&quot;,
			&quot;WAY&quot;, &quot;WAYS&quot;, &quot;WELL&quot;, &quot;WELLS&quot;, &quot;WL&quot;, &quot;WLS&quot;, &quot;WY&quot;, &quot;XING&quot;, &quot;XRD&quot;,
			&quot;XRDS&quot;, &quot;AVENIDA&quot;, &quot;CALLE&quot;, &quot;CLL&quot;, &quot;CAMINITO&quot;, &quot;CMT&quot;, &quot;CAMINO&quot;,
			&quot;CAM&quot;, &quot;CERRADA&quot;, &quot;CER&quot;, &quot;CIRCULO&quot;, &quot;ENTRADA&quot;, &quot;ENT&quot;, &quot;PASEO&quot;,
			&quot;PSO&quot;, &quot;PLACITA&quot;, &quot;PLA&quot;, &quot;RANCHO&quot;, &quot;RCH&quot;, &quot;VEREDA&quot;, &quot;VER&quot;, &quot;VIS&quot;);

	// See https://pe.usps.com/text/pub28/pub28apc_003.htm
<span class="fc" id="L168">	private static final Pattern unitPattern = ParserUtils.toPattern(</span>
			&quot;Apartment&quot;, &quot;APT&quot;, &quot;Basement&quot;, &quot;BLDG&quot;, &quot;BOX&quot;, &quot;BSMT&quot;, &quot;Building&quot;,
			&quot;Department&quot;, &quot;DEPT&quot;, &quot;FL&quot;, &quot;Floor&quot;, &quot;FRNT&quot;, &quot;Front&quot;, &quot;Hanger&quot;,
			&quot;HNGR&quot;, &quot;KEY&quot;, &quot;Key&quot;, &quot;LBBY&quot;, &quot;Lobby&quot;, &quot;LOT&quot;, &quot;Lot&quot;, &quot;Lower&quot;,
			&quot;LOWR&quot;, &quot;OFC&quot;, &quot;Office&quot;, &quot;Penthouse&quot;, &quot;PH&quot;, &quot;PIER&quot;, &quot;Pier&quot;, &quot;REAR&quot;,
			&quot;Rear&quot;, &quot;RM&quot;, &quot;Room&quot;, &quot;SIDE&quot;, &quot;Side&quot;, &quot;SLIP&quot;, &quot;Slip&quot;, &quot;Space&quot;,
			&quot;SPC&quot;, &quot;STE&quot;, &quot;STOP&quot;, &quot;Stop&quot;, &quot;Suite&quot;, &quot;Trailer&quot;, &quot;TRLR&quot;, &quot;UNIT&quot;,
			&quot;Unit&quot;, &quot;Upper&quot;, &quot;UPPR&quot;, &quot;Altura&quot;, &quot;ALT&quot;, &quot;Alturas&quot;, &quot;ALTS&quot;,
			&quot;Barriada&quot;, &quot;BDA&quot;, &quot;Barrio&quot;, &quot;BO&quot;, &quot;Carretera&quot;, &quot;CARR&quot;,
			&quot;Condominio&quot;, &quot;COND&quot;, &quot;Cooperativa&quot;, &quot;COO&quot;, &quot;Departamento&quot;, &quot;DEPT&quot;,
			&quot;Edificio&quot;, &quot;EDIF&quot;, &quot;Estancias&quot;, &quot;EST&quot;, &quot;Extensión&quot;, &quot;EXT&quot;,
			&quot;Industrial Interior&quot;, &quot;IND INT&quot;, &quot;Jardines&quot;, &quot;JARD&quot;, &quot;Mansiones&quot;,
			&quot;MANS&quot;, &quot;Parcelas&quot;, &quot;PARC&quot;, &quot;Quebrada&quot;, &quot;QBDA&quot;, &quot;Reparto&quot;, &quot;REPTO&quot;,
			&quot;Residencial&quot;, &quot;RES&quot;, &quot;Sector&quot;, &quot;SECT&quot;, &quot;Sección&quot;, &quot;SECC&quot;,
			&quot;Terraza&quot;, &quot;TERR&quot;, &quot;Urbanización&quot;, &quot;URB&quot;);

<span class="fc" id="L184">	private static final Pattern directionalPattern = ParserUtils.toPattern(&quot;N&quot;,</span>
			&quot;NORTE&quot;, &quot;NORTH&quot;, &quot;NE&quot;, &quot;NORESTE&quot;, &quot;NORTHEAST&quot;, &quot;NW&quot;, &quot;NOROESTE&quot;,
			&quot;NORTHWEST&quot;, &quot;S&quot;, &quot;SUR&quot;, &quot;SOUTH&quot;, &quot;SE&quot;, &quot;SURESTE&quot;, &quot;SOUTHEAST&quot;,
			&quot;SW&quot;, &quot;SUROESTE&quot;, &quot;SOUTHWEST&quot;, &quot;E&quot;, &quot;ESTE&quot;, &quot;EAST&quot;, &quot;W&quot;, &quot;OESTE&quot;,
			&quot;WEST&quot;);

	/**
	 * Construct a new AddressParser
	 */
<span class="fc" id="L193">	public AddressParser() {</span>
		// Construct the default address parser
<span class="fc" id="L195">	}</span>
	
	/**
	 * Get state abbreviation for state name or abbreviation
	 * @param state state name or abbreviation
	 * @return	The state abbreviation
	 */
	public static String getStateAbbreviation(String state) {
<span class="nc" id="L203">		String[] array = STATE_MAP.get(StringUtils.upperCase(state));</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">		return array == null ? null : array[0];</span>
	}
	
	/**
	 * Get state name for state name or abbreviation
	 * @param state state name or abbreviation
	 * @return	The state name
	 */
	public static String getStateName(String state) {
<span class="nc" id="L213">		String[] array = STATE_MAP.get(StringUtils.upperCase(state));</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">		return array == null ? null : array[1];</span>
	}
	
	@Override
	public Class&lt;Address&gt; type() {
<span class="nc" id="L219">		return Address.class;</span>
	}
	
	@Override
	public Address convert(Type type) {
<span class="fc" id="L224">		Address addr = null;</span>
<span class="fc" id="L225">		type = DatatypeConverter.adjustIfVaries(type);</span>

<span class="pc bpc" id="L227" title="1 of 2 branches missed.">		if (type instanceof Primitive pt) {</span>
<span class="nc bnc" id="L228" title="All 2 branches missed.">			if (DatatypeConverter.isDeleted(pt)) {</span>
<span class="nc" id="L229">				return DatatypeConverter.markDeleted(new Address());</span>
			}
<span class="nc" id="L231">			addr = fromString(pt.getValue());</span>
<span class="pc bpc" id="L232" title="1 of 2 branches missed.">		} else if (type instanceof Composite comp) {</span>
<span class="pc bpc" id="L233" title="2 of 5 branches missed.">			switch (type.getName()) {</span>
			case &quot;AD&quot;, &quot;XAD&quot;:
<span class="fc" id="L235">				addr = parse(comp.getComponents(), 0);</span>
<span class="fc" id="L236">				break;</span>
			case &quot;SAD&quot;:
<span class="fc" id="L238">				addr = new Address().addLine(ParserUtils.toString(comp, 0));</span>
<span class="fc" id="L239">				break;</span>
			case &quot;LA1&quot;:
<span class="nc" id="L241">				Type[] types = comp.getComponents();</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">				if (types.length &gt; 8) {</span>
					// Recursive call to parse LA1-8 which is of type AD
<span class="nc" id="L244">					addr = convert(types[8]);</span>
				}
				break;
			case &quot;LA2&quot;:
<span class="fc" id="L248">				addr = parse(comp.getComponents(), 8);</span>
<span class="fc" id="L249">				break;</span>
			default:
				break;
			}
		} 
		
<span class="fc" id="L255">		removeEmptyLines(addr);</span>
<span class="fc bfc" id="L256" title="All 4 branches covered.">		if (addr == null || addr.isEmpty()) {</span>
<span class="fc" id="L257">			return null;</span>
		}
<span class="fc" id="L259">		return addr;</span>
	}

	private static void removeEmptyLines(Address addr) {
<span class="fc bfc" id="L263" title="All 4 branches covered.">		if (addr != null &amp;&amp; addr.hasLine()) {</span>
<span class="fc" id="L264">			Iterator&lt;StringType&gt; it = addr.getLine().iterator();</span>
<span class="fc bfc" id="L265" title="All 2 branches covered.">			while (it.hasNext()) {</span>
<span class="fc" id="L266">				StringType line = it.next(); </span>
<span class="pc bpc" id="L267" title="1 of 4 branches missed.">				if (line == null || line.isEmpty()) {</span>
<span class="fc" id="L268">					it.remove();</span>
				}
<span class="fc" id="L270">			}</span>
		}
<span class="fc" id="L272">	}</span>
	
	@Override 
	public Type convert(Address addr) {
<span class="nc" id="L276">		return null;</span>
	}
	@Override
	public Address fromString(String value) {
<span class="fc bfc" id="L280" title="All 2 branches covered.">		if (StringUtils.isBlank(value)) {</span>
<span class="fc" id="L281">			return null;</span>
		}
<span class="fc" id="L283">		String[] parts = value.split(&quot;[\\n\\r]&quot;);</span>
<span class="fc" id="L284">		String[] originalParts = parts;</span>
<span class="fc bfc" id="L285" title="All 2 branches covered.">		if (parts.length == 1) {</span>
<span class="fc" id="L286">			parts = value.split(&quot;,&quot;);</span>
		}
<span class="fc" id="L288">		Address addr = new Address();</span>
<span class="fc" id="L289">		addr.setText(value);</span>
<span class="fc bfc" id="L290" title="All 2 branches covered.">		for (int i = 0; i &lt; parts.length; i++) {</span>
<span class="fc" id="L291">			String part = StringUtils.normalizeSpace(parts[i]);</span>
<span class="pc bpc" id="L292" title="1 of 2 branches missed."> 			if (part.isEmpty()) {</span>
<span class="nc" id="L293">				continue;</span>
			}
<span class="fc bfc" id="L295" title="All 2 branches covered.">			if (!addr.hasLine()) {</span>
<span class="fc" id="L296">				getLineOrCsz(originalParts, addr, part);</span>
<span class="fc" id="L297">				continue;</span>
			} 
			
<span class="pc bpc" id="L300" title="1 of 2 branches missed.">			if (isAddressLine(part)) {</span>
<span class="nc" id="L301">				addr.addLine(part);</span>
<span class="nc" id="L302">				continue;</span>
			} 
			
<span class="fc bfc" id="L305" title="All 2 branches covered.">			if (isCountry(addr, part)) {</span>
<span class="fc" id="L306">				addr.setCountry(part);</span>
<span class="fc" id="L307">				continue;</span>
			} 
			
<span class="pc bpc" id="L310" title="1 of 2 branches missed.">			if (!addr.hasPostalCode()) {</span>
<span class="fc" id="L311">				getCityStatePostalCode(addr, part);</span>
			}
		}
<span class="pc bpc" id="L314" title="1 of 2 branches missed.">		return addr.isEmpty() ? null : addr;</span>
	}
	private static void getLineOrCsz(String[] originalParts, Address addr, String part) {
		// First line is usually an address line, but
		// sometimes it might just be a city, state and postal code
		// in cases of partial representations.
<span class="fc bfc" id="L320" title="All 2 branches covered.">		if (isCszOnly(originalParts)) {</span>
<span class="fc" id="L321">			getCityStatePostalCode(addr, part);</span>
		} else {
<span class="fc" id="L323">			addr.addLine(part);</span>
		}
<span class="fc" id="L325">	}</span>
	
	/**
	 * Returns true if part is a possible country name
	 * @param addr	The addr that may need a country
	 * @param part	The part to examine
	 * @return	true if addr needs country and part is a country name
	 */
	private static boolean isCountry(Address addr, String part) {
<span class="pc bpc" id="L334" title="1 of 2 branches missed.">		return !addr.hasCountry()</span>
<span class="fc bfc" id="L335" title="All 2 branches covered.">				&amp;&amp; countryPattern.matcher(part).matches();</span>
	}
	/**
	 * Returns true if an address part matches patterns indicating it is an address line.
	 * 
	 * NOTE: Not all address lines will be matched, only those containing certain patterns
	 * that match (e.g., those with a street name or abbreviation, a directional indicator, or a unit number)
	 * @param part	The string to match
	 * @return true if it appears to be an address line, false if it doesn't match any known patterns.
	 */
	private static boolean isAddressLine(String part) {
<span class="pc bpc" id="L346" title="1 of 2 branches missed.">		return streetPattern.matcher(part).matches()</span>
<span class="pc bpc" id="L347" title="1 of 2 branches missed.">				|| directionalPattern.matcher(part).matches()</span>
<span class="pc bpc" id="L348" title="1 of 2 branches missed.">				|| unitPattern.matcher(part).matches();</span>
	}
	
	/**
	 * Check for odd cases like:
	 * Just CSZ: Chicago, IL, 65932
	 * Just CS and Country: Myfaircity, GA\nUSA
	 * Just State: Indiana
	 * @return true if it's an odd case.
	 */
	private static boolean isCszOnly(String[] parts) {
<span class="fc bfc" id="L359" title="All 2 branches covered.">		if (parts.length &gt; 2) {</span>
<span class="fc" id="L360">			return false;</span>
		}
<span class="fc bfc" id="L362" title="All 2 branches covered.">		if (parts.length == 2 &amp;&amp; </span>
<span class="pc bpc" id="L363" title="1 of 2 branches missed.">			!countryPattern.matcher(StringUtils.trim(parts[1])).matches()</span>
		) {
<span class="fc" id="L365">			return false;</span>
		}
<span class="fc" id="L367">		return isCszOnly(StringUtils.trim(parts[0]));</span>
	}
	
	private static boolean isCszOnly(String line) {
<span class="fc" id="L371">		boolean hasCa1Part = false;</span>
<span class="fc" id="L372">		boolean hasPostalCode = false;</span>
<span class="fc" id="L373">		boolean hasState = false;</span>
<span class="fc" id="L374">		boolean hasAnythingAfterState = false;</span>
<span class="fc bfc" id="L375" title="All 2 branches covered.">		for (String part : line.split(&quot;[ ,]+&quot;)) {</span>
<span class="fc bfc" id="L376" title="All 2 branches covered.">			if (postalCodePattern.matcher(part).matches()) {</span>
<span class="fc" id="L377">				hasPostalCode = true;</span>
<span class="pc bpc" id="L378" title="1 of 2 branches missed.">			} else if (caPostalCode1.matcher(part).matches()) {</span>
<span class="nc" id="L379">				hasCa1Part = true;</span>
<span class="pc bpc" id="L380" title="1 of 2 branches missed.">			} else if (caPostalCode2.matcher(part).matches()) {</span>
<span class="nc" id="L381">				hasPostalCode = hasCa1Part;</span>
<span class="fc bfc" id="L382" title="All 2 branches covered.">			} else if (statePattern.matcher(part).matches()) {</span>
<span class="fc" id="L383">				hasState = true;</span>
<span class="pc bpc" id="L384" title="1 of 2 branches missed.">			} else if (hasState) {</span>
				// Pennsylvania Ave would result in a false match if we didn't check
				// for anything else on the line other that postalCode and state
<span class="nc" id="L387">				hasAnythingAfterState = true;</span>
			}
		}
<span class="pc bpc" id="L390" title="2 of 6 branches missed.">		return (hasState || hasPostalCode) &amp;&amp; !hasAnythingAfterState;</span>
	}

	private static void getCityStatePostalCode(Address addr, String part) {
		// could be an address line, country, or some combination of
		// city, state, and postal code

<span class="fc" id="L397">		String[] lineParts = part.split(&quot;[, ]+&quot;);</span>
<span class="fc" id="L398">		lineParts = getPostalCode(addr, lineParts);</span>
<span class="fc" id="L399">		lineParts = getState(addr, lineParts);</span>
<span class="fc" id="L400">		lineParts = getCountry(addr, lineParts);</span>
		// City is anything left
<span class="fc bfc" id="L402" title="All 2 branches covered.">		if (lineParts.length != 0) {</span>
<span class="fc" id="L403">			addr.setCity(StringUtils.joinWith(&quot; &quot;, (Object[])lineParts));</span>
		}
<span class="fc" id="L405">	}</span>
	private static String[] getCountry(Address addr, String[] lineParts) {
<span class="fc" id="L407">		int position = 0;</span>
<span class="fc bfc" id="L408" title="All 2 branches covered.">		for (String linePart : lineParts) {</span>
<span class="pc bpc" id="L409" title="1 of 2 branches missed.">			if (countryPattern.matcher(linePart).matches()) {</span>
<span class="nc" id="L410">				addr.setCountry(linePart);</span>
<span class="nc" id="L411">				return ParserUtils.removeArrayElement(lineParts, position);</span>
			}
<span class="fc" id="L413">			++position;</span>
		}
<span class="fc" id="L415">		return lineParts;</span>
	}
	private static String[] getState(Address addr, String[] lineParts) {
<span class="fc" id="L418">		int position = 0;</span>
<span class="fc bfc" id="L419" title="All 2 branches covered.">		for (String linePart : lineParts) {</span>
<span class="fc bfc" id="L420" title="All 2 branches covered.">			if (statePattern.matcher(linePart).matches()) {</span>
<span class="fc" id="L421">				addr.setState(linePart);</span>
<span class="fc" id="L422">				return ParserUtils.removeArrayElement(lineParts, position);</span>
			}
<span class="fc" id="L424">			++position;</span>
		}
<span class="fc" id="L426">		return lineParts;</span>
	}
	private static String[] getPostalCode(Address addr, String[] lineParts) {
<span class="fc" id="L429">		String postalPart1 = null;</span>
<span class="fc" id="L430">		int position = 0;</span>
<span class="fc bfc" id="L431" title="All 2 branches covered.">		for (String linePart : lineParts) {</span>
<span class="fc bfc" id="L432" title="All 2 branches covered.">			if (postalCodePattern.matcher(linePart).matches()) {</span>
<span class="fc" id="L433">				addr.setPostalCode(linePart);</span>
<span class="fc" id="L434">				return ParserUtils.removeArrayElement(lineParts, position);</span>
<span class="pc bpc" id="L435" title="2 of 4 branches missed.">			} else if (postalPart1 == null &amp;&amp; caPostalCode1.matcher(linePart).matches()) {</span>
<span class="nc" id="L436">				postalPart1 = linePart;</span>
<span class="pc bpc" id="L437" title="3 of 4 branches missed.">			} else if (postalPart1 != null &amp;&amp; caPostalCode2.matcher(linePart).matches()) {</span>
<span class="nc" id="L438">				addr.setPostalCode(postalPart1 + &quot; &quot; + linePart);</span>
				// Remove the part we just matched
<span class="nc" id="L440">				lineParts = ParserUtils.removeArrayElement(lineParts, position);</span>
				// And it's predecessor.
<span class="nc" id="L442">				return ParserUtils.removeArrayElement(lineParts, position - 1);</span>
			} else {
<span class="fc" id="L444">				postalPart1 = null;</span>
			}
<span class="fc" id="L446">			++position;</span>
		}
<span class="fc" id="L448">		return lineParts;</span>
	}
	
	/**
	 * Parse a composite made up of types into an address.
	 * @param types	The components of the address
	 * @param offset The offset to the address line
	 * @return	A new FHIR Address populated from the values in types.
	 */
	public static Address parse(Type[] types, int offset) {
<span class="fc" id="L458">		Address addr = new Address();</span>
<span class="fc bfc" id="L459" title="All 2 branches covered.">		for (int i = 0; i &lt; 14; i++) {</span>
			
<span class="pc bpc" id="L461" title="1 of 2 branches missed.">			if (types.length + offset &lt;= i) {</span>
<span class="nc" id="L462">				break;</span>
			}
<span class="fc" id="L464">			Type t = DatatypeConverter.adjustIfVaries(types, i + offset);</span>
<span class="fc bfc" id="L465" title="All 2 branches covered.">			if (i == 0) {</span>
<span class="fc" id="L466">				addr.addLine(ParserUtils.toString(t));</span>
<span class="fc bfc" id="L467" title="All 2 branches covered.">			} else if (t instanceof Primitive part) {</span>
<span class="fc bfc" id="L468" title="All 8 branches covered.">				switch (i) {</span>
					case 1 :
<span class="fc" id="L470">						addr.addLine(part.getValue());</span>
<span class="fc" id="L471">						break;</span>
					case 2 :
<span class="fc" id="L473">						addr.setCity(part.getValue());</span>
<span class="fc" id="L474">						break;</span>
					case 3 :
<span class="fc" id="L476">						addr.setState(part.getValue());</span>
<span class="fc" id="L477">						break;</span>
					case 4 :
<span class="fc" id="L479">						addr.setPostalCode(part.getValue());</span>
<span class="fc" id="L480">						break;</span>
					case 5 :
<span class="fc" id="L482">						addr.setCountry(part.getValue());</span>
<span class="fc" id="L483">						break;</span>
					case 6 :
<span class="fc" id="L485">						addr.setUse(getUse(part.getValue()));</span>
<span class="fc" id="L486">						break;</span>
					case 8 :
<span class="fc" id="L488">						addr.setDistrict(part.getValue());</span>
<span class="fc" id="L489">						break;</span>
					default:
						break;
					}
			}
		}
<span class="fc bfc" id="L495" title="All 2 branches covered.">		if (addr.isEmpty()) {</span>
<span class="fc" id="L496">			return null;</span>
		}
<span class="fc" id="L498">		return addr;</span>
	}
	private static AddressUse getUse(String value) {
<span class="fc bfc" id="L501" title="All 2 branches covered.">		if (StringUtils.isBlank(value)) {</span>
<span class="fc" id="L502">			return null;</span>
		}
<span class="pc bpc" id="L504" title="4 of 5 branches missed.">		switch (value.trim().toUpperCase()) {</span>
			case &quot;B&quot;, // Firm/Business
				 &quot;O&quot; : // Office/Business
<span class="nc" id="L507">				return AddressUse.WORK;</span>
			case &quot;BI&quot; : // Billing Address
<span class="nc" id="L509">				return AddressUse.BILLING;</span>
			case &quot;C&quot; : // Current Or Temporary
<span class="nc" id="L511">				return AddressUse.TEMP;</span>
			case &quot;H&quot; : // Home
<span class="nc" id="L513">				return AddressUse.HOME;</span>
			case &quot;BA&quot;, // Bad address
				 &quot;BDL&quot;, // Birth delivery location (address where birth occurred)
				 &quot;BR&quot;, // Residence at birth (home address at time of birth)
				 &quot;F&quot;, // Country Of Origin
				 &quot;L&quot;, // Legal Address
				 &quot;M&quot;, // Mailing
				 &quot;N&quot;, // Birth (nee) (birth address, not otherwise specified)
				 &quot;P&quot;, // Permanent
				 &quot;RH&quot;, // Registry home
				 &quot;S&quot;, // Service Location
				 &quot;SH&quot;, // Shipping Address
				 &quot;TM&quot;, // Tube Address
				 &quot;V&quot; : // Vacation
			default :
<span class="fc" id="L528">				return null;</span>
		}
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>